

TableꢀofꢀContents

[Introduction](#br6)

LinkedꢀList

1.1

1.2

[LinkedꢀListꢀCycle](#br7)

1.2.1

1.2.2

1.2.3

1.2.4

1.2.5

1.2.6

1.2.7

1.2.8

1.2.9

1.2.10

1.2.11

1.2.12

1.3

[ReverseꢀLinkedꢀList](#br9)

[DeleteꢀNodeꢀinꢀaꢀLinkedꢀList](#br10)

[MergeꢀTwoꢀSortedꢀLists](#br11)

[IntersectionꢀofꢀTwoꢀLinkedꢀLists](#br14)

[LinkedꢀListꢀCycleꢀII](#br16)

[PalindromeꢀLinkedꢀList](#br18)

[RemoveꢀLinkedꢀListꢀElements](#br21)

[RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀList](#br23)

[RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀListꢀII](#br25)

[SwapꢀNodesꢀinꢀPairs](#br27)

[RemoveꢀNthꢀnodeꢀfromꢀEndꢀofꢀList](#br28)

[Trees](#br30)

[PreorderꢀTraversal](#br33)

1.3.1

1.3.2

1.3.3

1.3.4

1.3.5

1.3.6

1.3.7

1.3.8

1.3.9

1.3.10

1.3.11

1.3.12

[BSTꢀIterator](#br35)

[InorderꢀTraversal](#br37)

[SymmetricꢀTree](#br39)

[BalancedꢀBinaryꢀTree](#br41)

[ClosestꢀBSTꢀValue](#br43)

[PostorderꢀTraversal](#br46)

[MaximumꢀDepthꢀofꢀBinaryꢀTree](#br48)

[InvertꢀBinaryꢀTree](#br49)

[SameꢀTree](#br51)

[LowestꢀCommonꢀAncestorꢀofꢀaꢀBinaryꢀSearchꢀTree](#br52)

[LowestꢀCommonꢀAncestorꢀinꢀaꢀBinaryꢀTree](#br55)

1





[UniqueꢀBinaryꢀSearchꢀTrees](#br57)

1.3.13

1.3.14

1.3.15

1.3.16

1.3.17

1.3.18

1.3.19

1.3.20

1.3.21

1.3.22

1.3.23

1.3.24

1.3.25

1.3.26

1.3.27

1.3.28

1.3.29

1.3.30

1.3.31

1.3.32

1.3.33

1.3.34

1.3.35

1.3.36

1.3.37

1.3.38

1.4

[UniqueꢀBinaryꢀSearchꢀTreesꢀII](#br59)

[PathꢀSum](#br62)

[BinaryꢀTreeꢀMaximumꢀPathꢀSum](#br64)

[BinaryꢀTreeꢀLevelꢀOrderꢀTraversal](#br66)

[ValidateꢀBinaryꢀSearchꢀTree](#br68)

[MinimumꢀDepthꢀofꢀBinaryꢀTree](#br70)

[ConvertꢀSortedꢀArrayꢀtoꢀBinaryꢀSearchꢀTree](#br72)

[FlattenꢀBinaryꢀTreeꢀtoꢀLinkedꢀList](#br74)

[ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPreorderꢀTraversal](#br76)

[BinaryꢀTreeꢀPaths](#br78)

[RecoverꢀBinaryꢀSearchꢀTree](#br80)

[PathꢀSumꢀII](#br82)

[BinaryꢀLevelꢀOrderꢀTraversalꢀII](#br84)

[KthꢀSmallestꢀElementꢀinꢀaꢀBST](#br86)

[ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPostorderꢀTraversal](#br89)

[BinaryꢀTreeꢀRightꢀSideꢀView](#br91)

[SumꢀRootꢀtoꢀLeafꢀNumbers](#br93)

[BinaryꢀTreeꢀZigzagꢀLevelꢀOrderꢀTraversal](#br95)

[HouseꢀRobberꢀIII](#br97)

[InorderꢀSuccessorꢀinꢀBST](#br99)

[BinaryꢀTreeꢀLongestꢀConsecutiveꢀSequence](#br101)

[VerifyꢀPreorderꢀSequenceꢀinꢀBinaryꢀSearchꢀTree](#br103)

[BinaryꢀTreeꢀUpsideꢀDown](#br105)

[CountꢀUnivalueꢀSubtrees](#br107)

SerializeꢀandꢀDeserializeꢀBinaryꢀTree

Graphs

[NumberꢀofꢀConnectedꢀComponentsꢀinꢀanꢀUndirectedꢀGraph](#br109)

[CourseꢀSchedule](#br113)

1.4.1

1.4.2

[GraphꢀValidꢀTree](#br118)

1.4.3

2





[CourseꢀScheduleꢀ2](#br123)

[NumberꢀofꢀIslands](#br128)

1.4.4

1.4.5

Heaps

1.5

[MergeꢀKꢀSortedꢀLinkedꢀLists](#br130)

1.5.1

[KthꢀLargestꢀElementꢀinꢀanꢀArray](#br132)

1.5.2

Arrays

1.6

[2ꢀSumꢀII](#br133)

1.6.1

[2ꢀSumꢀIII](#br135)

1.6.2

[ContainsꢀDuplicate](#br137)

[RotateꢀArray](#br138)

1.6.3

1.6.4

[3ꢀSumꢀSmaller](#br140)

1.6.5

[3ꢀSumꢀClosest](#br142)

1.6.6

[3ꢀSum](#br145)

1.6.7

[TwoꢀSum](#br147)

1.6.8

[PlusꢀOne](#br148)

1.6.9

[BestꢀTimeꢀtoꢀBuyꢀandꢀSellꢀStock](#br150)

[ShortestꢀWordꢀDistance](#br151)

[MoveꢀZeroes](#br153)

1.6.10

1.6.11

1.6.12

1.6.13

1.6.14

1.6.15

1.6.16

1.6.17

1.6.18

1.6.19

1.6.20

1.6.21

1.6.22

1.6.23

1.6.24

[ContainsꢀDuplicateꢀII](#br154)

[MajorityꢀElement](#br156)

[RemoveꢀDuplicatesꢀfromꢀSortedꢀArray](#br159)

[NestedꢀListꢀWeightꢀSum](#br160)

[NestedꢀListꢀWeightedꢀSumꢀII](#br162)

[RemoveꢀElement](#br163)

[IntersectionꢀofꢀTwoꢀArraysꢀII](#br165)

[MergeꢀSortedꢀArrays](#br167)

[ReverseꢀVowelsꢀofꢀaꢀString](#br169)

[IntersectionꢀofꢀTwoꢀArrays](#br171)

[ContainerꢀWithꢀMostꢀWater](#br172)

[ProductꢀofꢀArrayꢀExceptꢀSelf](#br173)

3





[TrappingꢀRainꢀWater](#br174)

1.6.25

1.6.26

1.6.27

1.6.28

1.6.29

1.6.30

1.6.31

1.6.32

1.7

[MaximumꢀSubarray](#br176)

[BestꢀTimeꢀtoꢀBuyꢀandꢀSellꢀStockꢀII](#br178)

[FindꢀMinimumꢀinꢀRotatedꢀSortedꢀArray](#br179)

[Pascal'sꢀTriangle](#br180)

[Pascal'sꢀTriangleꢀII](#br182)

[SummaryꢀRanges](#br183)

[MissingꢀNumber](#br184)

Strings

[ValidꢀAnagram](#br185)

[ValidꢀPalindrome](#br186)

[WordꢀPattern](#br187)

1.7.1

1.7.2

1.7.3

1.7.4

1.7.5

1.7.6

1.8

[ValidꢀParentheses](#br189)

[IsomorphicꢀStrings](#br191)

[ReverseꢀString](#br193)

BitꢀManipulation

[SumꢀofꢀTwoꢀIntegers](#br194)

[SingleꢀNumber](#br195)

1.8.1

1.8.2

1.8.3

1.8.4

1.9

SingleꢀNumberꢀII

SingleꢀNumberꢀIII

Maths

[ReverseꢀInteger](#br196)

1.9.1

1.9.2

1.9.3

1.9.4

1.9.5

1.9.6

1.9.7

1.9.8

1.9.9

[PalindromeꢀNumber](#br198)

[Pow(x,n)](#br200)

[Subsets](#br201)

[SubsetsꢀII](#br203)

FractionꢀtoꢀRecurringꢀDecimal

ExcelꢀSheetꢀColumnꢀNumber

ExcelꢀSheetꢀColumnꢀTitle

FactorialꢀTrailingꢀZeros

4





HappyꢀNumber

CountꢀPrimes

1.9.10

1.9.11

1.9.12

1.9.13

1.9.14

1.9.15

1.9.16

1.9.17

1.9.18

1.9.19

1.9.20

1.9.21

1.9.22

1.9.23

1.9.24

1.9.25

1.9.26

1.9.27

1.9.28

1.10

PlusꢀOne

DivideꢀTwoꢀIntegers

MultiplyꢀStrings

MaxꢀPointsꢀonꢀaꢀLine

ProductꢀofꢀArrayꢀExceptꢀSelf

[PowerꢀofꢀThree](#br205)

IntegerꢀBreak

PowerꢀofꢀFour

AddꢀDigits

UglyꢀNumber

UglyꢀNumberꢀII

SuperꢀUglyꢀNumber

FindꢀKꢀPairsꢀwithꢀSmallestꢀSums

[SelfꢀCrossing](#br206)

[PaintꢀFence](#br208)

[BulbꢀSwitcher](#br209)

[NimꢀGame](#br210)

Matrix

[RotateꢀImage](#br211)

1.10.1

1.10.2

1.10.3

1.10.4

1.10.5

1.10.6

1.11

[SetꢀMatrixꢀZeroes](#br212)

[Searchꢀaꢀ2DꢀMatrix](#br215)

[Searchꢀaꢀ2DꢀMatrixꢀII](#br217)

[SpiralꢀMatrix](#br219)

[SpiralꢀMatrixꢀII](#br221)

[Design](#br223)

[LRUꢀCache](#br224)

1.11.1

5





Introduction

MyꢀLeetcodeꢀSolutionsꢀinꢀPython

ThisꢀbookꢀwillꢀcontainꢀmyꢀsolutionsꢀinꢀPythonꢀtoꢀtheꢀleetcodeꢀproblems.ꢀCurrently,ꢀI

willꢀjustꢀtryꢀtoꢀpostꢀtheꢀacceptedꢀsolutions.ꢀTheꢀplanꢀisꢀtoꢀeventuallyꢀinclude

detailedꢀexplanationsꢀofꢀeachꢀandꢀeveryꢀsolution.ꢀIꢀamꢀdoingꢀthisꢀjustꢀforꢀfun.

6





LinkedꢀListꢀCycle

LinkedꢀListꢀCycle

Givenꢀaꢀlinkedꢀlist,ꢀdetermineꢀifꢀitꢀhasꢀaꢀcycleꢀinꢀit.

Followꢀup:ꢀCanꢀyouꢀsolveꢀitꢀwithoutꢀusingꢀextraꢀspace?

URL:ꢀhttps://leetcode.com/problems/linked-list-cycle/

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀhasCycle(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀfastꢀ!=ꢀNoneꢀandꢀfast.nextꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀfastꢀ==ꢀslow:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbreak

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀfastꢀ==ꢀNoneꢀorꢀfast.nextꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀfastꢀ==ꢀslow:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

7





LinkedꢀListꢀCycle

8





ReverseꢀLinkedꢀList

ReverseꢀLinkedꢀList

Reverseꢀaꢀsinglyꢀlinkedꢀlist.

URL:ꢀhttps://leetcode.com/problems/reverse-linked-list/

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀreverseList(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadꢀ!=ꢀNoneꢀandꢀhead.nextꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnext\_nodeꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀheadꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnext\_nodeꢀ=ꢀhead.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhead.nextꢀ=ꢀtemp

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheadꢀ=ꢀnext\_node

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀtemp

9





DeleteꢀNodeꢀinꢀaꢀLinkedꢀList

DeleteꢀNodeꢀinꢀaꢀLinkedꢀList

Writeꢀaꢀfunctionꢀtoꢀdeleteꢀaꢀnodeꢀ(exceptꢀtheꢀtail)ꢀinꢀaꢀsinglyꢀlinkedꢀlist,ꢀgivenꢀonly

accessꢀtoꢀthatꢀnode.

Supposedꢀtheꢀlinkedꢀlistꢀisꢀ1ꢀ->ꢀ2ꢀ->ꢀ3ꢀ->ꢀ4ꢀandꢀyouꢀareꢀgivenꢀtheꢀthirdꢀnodeꢀwith

valueꢀ3,ꢀtheꢀlinkedꢀlistꢀshouldꢀbecomeꢀ1ꢀ->ꢀ2ꢀ->ꢀ4ꢀafterꢀcallingꢀyourꢀfunction.

URL:ꢀhttps://leetcode.com/problems/delete-node-in-a-linked-list/

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀdeleteNode(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnode:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀnodeꢀin-plac

eꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnext\_nodeꢀ=ꢀnode.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode.valꢀ=ꢀnext\_node.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode.nextꢀ=ꢀnext\_node.next

10





MergeꢀTwoꢀSortedꢀLists

MergeꢀTwoꢀSortedꢀLists

Mergeꢀtwoꢀsortedꢀlinkedꢀlistsꢀandꢀreturnꢀitꢀasꢀaꢀnewꢀlist.ꢀTheꢀnewꢀlistꢀshouldꢀbe

madeꢀbyꢀsplicingꢀtogetherꢀtheꢀnodesꢀofꢀtheꢀfirstꢀtwoꢀlists.

URL:ꢀhttps://leetcode.com/problems/merge-two-sorted-lists/

11





MergeꢀTwoꢀSortedꢀLists

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmergeTwoLists(self,ꢀl1,ꢀl2):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀl1:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀl2:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀl1ꢀ==ꢀNoneꢀandꢀl2ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀl1ꢀ!=ꢀNoneꢀandꢀl2ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀl1

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀl2ꢀ!=ꢀNoneꢀandꢀl1ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀl2

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummyꢀ=ꢀListNode(0)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀdummy

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀl1ꢀ!=ꢀNoneꢀandꢀl2ꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀl1.valꢀ<ꢀl2.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.nextꢀ=ꢀl1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀl1ꢀ=ꢀl1.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.nextꢀ=ꢀl2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀl2ꢀ=ꢀl2.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀp.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀl1ꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.nextꢀ=ꢀl1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀl2ꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.nextꢀ=ꢀl2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdummy.next

12





MergeꢀTwoꢀSortedꢀLists

13





IntersectionꢀofꢀTwoꢀLinkedꢀLists

IntersectionꢀofꢀTwoꢀLinkedꢀLists

Writeꢀaꢀprogramꢀtoꢀfindꢀtheꢀnodeꢀatꢀwhichꢀtheꢀintersectionꢀofꢀtwoꢀsinglyꢀlinkedꢀlists

begins.

Forꢀexample,ꢀtheꢀfollowingꢀtwoꢀlinkedꢀlists:

A:ꢀa1ꢀ→ꢀa2ꢀ↘ꢀc1ꢀ→ꢀc2ꢀ→ꢀc3ꢀ↗

B:ꢀb1ꢀ→ꢀb2ꢀ→ꢀb3ꢀbeginꢀtoꢀintersectꢀatꢀnodeꢀc1.

Notes:

Ifꢀtheꢀtwoꢀlinkedꢀlistsꢀhaveꢀnoꢀintersectionꢀatꢀall,ꢀreturnꢀnull.ꢀTheꢀlinkedꢀlistsꢀmust

retainꢀtheirꢀoriginalꢀstructureꢀafterꢀtheꢀfunctionꢀreturns.ꢀYouꢀmayꢀassumeꢀthereꢀare

noꢀcyclesꢀanywhereꢀinꢀtheꢀentireꢀlinkedꢀstructure.ꢀYourꢀcodeꢀshouldꢀpreferablyꢀrun

inꢀO(n)ꢀtimeꢀandꢀuseꢀonlyꢀO(1)ꢀmemory.

URL:ꢀhttps://leetcode.com/problems/intersection-of-two-linked-lists/

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgetIntersectionNode(self,ꢀheadA,ꢀheadB):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead1,ꢀhead1:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadAꢀ==ꢀNoneꢀandꢀheadBꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadAꢀ==ꢀNoneꢀandꢀheadBꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadAꢀ!=ꢀNoneꢀandꢀheadBꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_aꢀ=ꢀ0

14





IntersectionꢀofꢀTwoꢀLinkedꢀLists

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_bꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀheadA

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_aꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀheadB

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_bꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdiffꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen\_aꢀ>ꢀlen\_b:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdiffꢀ=ꢀlen\_aꢀ-ꢀlen\_b

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentAꢀ=ꢀheadA

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentBꢀ=ꢀheadB

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdiffꢀ=ꢀlen\_bꢀ-ꢀlen\_a

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentAꢀ=ꢀheadB

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentBꢀ=ꢀheadA

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcountꢀ<ꢀdiff:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentAꢀ=ꢀcurrentA.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentAꢀ!=ꢀNoneꢀandꢀcurrentBꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrentAꢀ==ꢀcurrentB:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcurrentA

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentAꢀ=ꢀcurrentA.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentBꢀ=ꢀcurrentB.next

15





LinkedꢀListꢀCycleꢀII

LinkedꢀListꢀCycleꢀII

Givenꢀaꢀlinkedꢀlist,ꢀreturnꢀtheꢀnodeꢀwhereꢀtheꢀcycleꢀbegins.ꢀIfꢀthereꢀisꢀnoꢀcycle,

returnꢀnull.

Note:ꢀDoꢀnotꢀmodifyꢀtheꢀlinkedꢀlist.

Followꢀup:ꢀCanꢀyouꢀsolveꢀitꢀwithoutꢀusingꢀextraꢀspace?

URL:ꢀhttps://leetcode.com/problems/linked-list-cycle-ii/

16





LinkedꢀListꢀCycleꢀII

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀdetectCycle(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhas\_cycleꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀfastꢀ!=ꢀNoneꢀandꢀfast.nextꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀfastꢀ==ꢀslow:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhas\_cycleꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbreak

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀhas\_cycleꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀfastꢀ!=ꢀslow:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀslow

17





PalindromeꢀLinkedꢀList

PalindromeꢀLinkedꢀList

Givenꢀaꢀsinglyꢀlinkedꢀlist,ꢀdetermineꢀifꢀitꢀisꢀaꢀpalindrome.

Followꢀup:ꢀCouldꢀyouꢀdoꢀitꢀinꢀO(n)ꢀtimeꢀandꢀO(1)ꢀspace?

URL:ꢀhttps://leetcode.com/problems/palindrome-linked-list/

18





PalindromeꢀLinkedꢀList

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisPalindrome(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadꢀ!=ꢀNoneꢀandꢀhead.nextꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀfastꢀ!=ꢀNoneꢀandꢀfast.nextꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(slow.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#madamꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀfastꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀslowꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀslow.valꢀ!=ꢀstack.pop():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

19





PalindromeꢀLinkedꢀList

20





RemoveꢀLinkedꢀListꢀElements

RemoveꢀLinkedꢀListꢀElements

Removeꢀallꢀelementsꢀfromꢀaꢀlinkedꢀlistꢀofꢀintegersꢀthatꢀhaveꢀvalueꢀval.

ExampleꢀGiven:ꢀ1ꢀ-->ꢀ2ꢀ-->ꢀ6ꢀ-->ꢀ3ꢀ-->ꢀ4ꢀ-->ꢀ5ꢀ-->ꢀ6,ꢀvalꢀ=ꢀ6ꢀReturn:ꢀ1ꢀ-->ꢀ2ꢀ-->ꢀ3ꢀ-->

4ꢀ-->ꢀ5

URL:ꢀhttps://leetcode.com/problems/remove-linked-list-elements/

21





RemoveꢀLinkedꢀListꢀElements

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀremoveElements(self,ꢀhead,ꢀval):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀval:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadꢀ!=ꢀNoneꢀandꢀhead.nextꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀhead.valꢀ==ꢀval:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummyꢀ=ꢀListNode(0)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummy.nextꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprevꢀ=ꢀdummy

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀheadꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀhead.valꢀ==ꢀval:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprev.nextꢀ=ꢀhead.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheadꢀ=ꢀprev

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprevꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheadꢀ=ꢀhead.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdummy.next

22





RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀList

RemoveꢀDuplicatesꢀfromꢀSortedꢀLinked

List

Givenꢀaꢀsortedꢀlinkedꢀlist,ꢀdeleteꢀallꢀduplicatesꢀsuchꢀthatꢀeachꢀelementꢀappearꢀonly

once.

Forꢀexample,ꢀGivenꢀ1->1->2,ꢀreturnꢀ1->2.ꢀGivenꢀ1->1->2->3->3,ꢀreturnꢀ1->2->3.

URL:ꢀhttps://leetcode.com/problems/remove-duplicates-from-sorted-list/

23





RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀList

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀdeleteDuplicates(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀheadꢀ!=ꢀNoneꢀandꢀhead.nextꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookupꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprevꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.valꢀinꢀlookup:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprev.nextꢀ=ꢀprev.next.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookup[current.val]ꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprevꢀ=ꢀcurrent

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

24





RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀListꢀII

RemoveꢀDuplicatesꢀfromꢀSortedꢀLinked

ListꢀII

Givenꢀaꢀsortedꢀlinkedꢀlist,ꢀdeleteꢀallꢀnodesꢀthatꢀhaveꢀduplicateꢀnumbers,ꢀleaving

onlyꢀdistinctꢀnumbersꢀfromꢀtheꢀoriginalꢀlist.

Forꢀexample,ꢀGivenꢀ1->2->3->3->4->4->5,ꢀreturnꢀ1->2->5.ꢀGivenꢀ1->1->1->2->3,

returnꢀ2->3.

URL:ꢀhttps://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀdeleteDuplicates(self,ꢀhead):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdup\_dictꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.valꢀinꢀdup\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdup\_dict[current.val]ꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdup\_dict[current.val]ꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlist\_valuesꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentꢀ!=ꢀNone:

25





RemoveꢀDuplicatesꢀfromꢀSortedꢀLinkedꢀListꢀII

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀdup\_dict[current.val]ꢀ>ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlist\_values.append(current.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlist\_valuesꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode1ꢀ=ꢀListNode(list\_values[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheadꢀ=ꢀnode1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀlist\_values[1:]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnew\_nodeꢀ=ꢀListNode(entries)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode1.nextꢀ=ꢀnew\_node

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode1ꢀ=ꢀnew\_node

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

26





SwapꢀNodesꢀinꢀPairs

SwapꢀNodesꢀinꢀPairs

27





RemoveꢀNthꢀnodeꢀfromꢀEndꢀofꢀList

RemoveꢀNthꢀnodeꢀfromꢀEndꢀofꢀList

Givenꢀaꢀlinkedꢀlist,ꢀremoveꢀtheꢀnthꢀnodeꢀfromꢀtheꢀendꢀofꢀlistꢀandꢀreturnꢀitsꢀhead.

Forꢀexample,

Givenꢀlinkedꢀlist:ꢀ1->2->3->4->5,ꢀandꢀnꢀ=ꢀ2.

Afterꢀremovingꢀtheꢀsecondꢀnodeꢀfromꢀtheꢀend,ꢀtheꢀlinkedꢀlistꢀbecomesꢀ1->2->3->5.

Note:ꢀGivenꢀnꢀwillꢀalwaysꢀbeꢀvalid.ꢀTryꢀtoꢀdoꢀthisꢀinꢀoneꢀpass.

URL:ꢀhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/

28





RemoveꢀNthꢀnodeꢀfromꢀEndꢀofꢀList

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

#ꢀclassꢀListNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀremoveNthFromEnd(self,ꢀhead,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀhead:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheadꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummyꢀ=ꢀListNode(0)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummy.nextꢀ=ꢀhead

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀdummy

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀdummy

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(n):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀfast.nextꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfastꢀ=ꢀfast.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslowꢀ=ꢀslow.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀslow.nextꢀ=ꢀslow.next.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdummy.next

29





Trees

Serializationꢀisꢀtheꢀprocessꢀofꢀconvertingꢀaꢀdataꢀstructureꢀorꢀobjectꢀintoꢀa

sequenceꢀofꢀbitsꢀsoꢀthatꢀitꢀcanꢀbeꢀstoredꢀinꢀaꢀfileꢀorꢀmemoryꢀbuffer,ꢀorꢀtransmitted

acrossꢀaꢀnetworkꢀconnectionꢀlinkꢀtoꢀbeꢀreconstructedꢀlaterꢀinꢀtheꢀsameꢀorꢀanother

computerꢀenvironment.

Designꢀanꢀalgorithmꢀtoꢀserializeꢀandꢀdeserializeꢀaꢀbinaryꢀtree.ꢀThereꢀisꢀno

restrictionꢀonꢀhowꢀyourꢀserialization/deserializationꢀalgorithmꢀshouldꢀwork.ꢀYouꢀjust

needꢀtoꢀensureꢀthatꢀaꢀbinaryꢀtreeꢀcanꢀbeꢀserializedꢀtoꢀaꢀstringꢀandꢀthisꢀstringꢀcan

beꢀdeserializedꢀtoꢀtheꢀoriginalꢀtreeꢀstructure.

Forꢀexample,ꢀyouꢀmayꢀserializeꢀtheꢀfollowingꢀtree

1

ꢀꢀꢀ/ꢀ\

ꢀꢀ2ꢀꢀꢀ3

ꢀꢀꢀꢀꢀ/ꢀ\

ꢀꢀꢀꢀ4ꢀꢀꢀ5

as

ꢀ"[1,2,3,null,null,4,5]"ꢀ

,ꢀjustꢀtheꢀsameꢀas

howꢀLeetCodeꢀOJꢀserializesꢀaꢀbinaryꢀtree

.ꢀYouꢀdoꢀnotꢀnecessarilyꢀneedꢀtoꢀfollowꢀthisꢀformat,ꢀsoꢀpleaseꢀbeꢀcreativeꢀand

comeꢀupꢀwithꢀdifferentꢀapproachesꢀyourself.

Note:Doꢀnotꢀuseꢀclassꢀmember/global/staticꢀvariablesꢀtoꢀstoreꢀstates.ꢀYour

serializeꢀandꢀdeserializeꢀalgorithmsꢀshouldꢀbeꢀstateless.

URL:ꢀhttps://leetcode.com/problems/serialize-and-deserialize-binary-tree/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

30





Trees

classꢀCodec:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.serialized\_arrayꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀself.indexꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀserialize(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""Encodesꢀaꢀtreeꢀtoꢀaꢀsingleꢀstring.

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.serialization\_help(root)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.serialized\_array

ꢀꢀꢀꢀdefꢀserialization\_help(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.serialized\_array.append(None)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.serialized\_array.append(root.val)

ꢀꢀꢀꢀꢀꢀꢀꢀself.serialize(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀself.serialize(root.right)

ꢀꢀꢀꢀdefꢀdeserialize(self,ꢀdata):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""Decodesꢀyourꢀencodedꢀdataꢀtoꢀtree.

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀdata:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.indexꢀ==ꢀlen(data)ꢀorꢀdata[self.index]ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.indexꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀTreeNode(data[self.index])

ꢀꢀꢀꢀꢀꢀꢀꢀself.indexꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀroot.leftꢀ=ꢀself.deserialize(data)

ꢀꢀꢀꢀꢀꢀꢀꢀroot.rightꢀ=ꢀself.deserialize(data)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

31





Trees

#ꢀYourꢀCodecꢀobjectꢀwillꢀbeꢀinstantiatedꢀandꢀcalledꢀasꢀsuch:

#ꢀcodecꢀ=ꢀCodec()

#ꢀcodec.deserialize(codec.serialize(root))

32





PreorderꢀTraversal

PreorderꢀTraversal

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀpreorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ{1,#,2,3},ꢀ1ꢀ\ꢀ2ꢀ/ꢀ3ꢀreturnꢀ[1,2,3].

Note:ꢀRecursiveꢀsolutionꢀisꢀtrivial,ꢀcouldꢀyouꢀdoꢀitꢀiteratively?

URL:ꢀhttps://leetcode.com/problems/binary-tree-preorder-traversal/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[]}

ꢀꢀꢀꢀdefꢀpreorderTraversal(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpreorderListꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhile(stackꢀ!=ꢀ[]):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpreorderList.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀpreorderList

33





PreorderꢀTraversal

34





BSTꢀIterator

BSTꢀIterator

Implementꢀanꢀiteratorꢀoverꢀaꢀbinaryꢀsearchꢀtreeꢀ(BST).ꢀYourꢀiteratorꢀwillꢀbe

initializedꢀwithꢀtheꢀrootꢀnodeꢀofꢀaꢀBST.

Callingꢀnext()ꢀwillꢀreturnꢀtheꢀnextꢀsmallestꢀnumberꢀinꢀtheꢀBST.

Note:ꢀnext()ꢀandꢀhasNext()ꢀshouldꢀrunꢀinꢀaverageꢀO(1)ꢀtimeꢀandꢀusesꢀO(h)

memory,ꢀwhereꢀhꢀisꢀtheꢀheightꢀofꢀtheꢀtree.

URL:ꢀhttps://leetcode.com/problems/binary-search-tree-iterator/

35





BSTꢀIterator

#ꢀDefinitionꢀforꢀaꢀꢀbinaryꢀtreeꢀnode

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀBSTIterator:

ꢀꢀꢀꢀ#ꢀ@paramꢀroot,ꢀaꢀbinaryꢀsearchꢀtree'sꢀrootꢀnode

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀself.stackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀnodeꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.stack.append(node)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀnode.left

ꢀꢀꢀꢀ#ꢀ@returnꢀaꢀboolean,ꢀwhetherꢀweꢀhaveꢀaꢀnextꢀsmallestꢀnumber

ꢀꢀꢀꢀdefꢀhasNext(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlen(self.stack)ꢀ!=ꢀ0

ꢀꢀꢀꢀ#ꢀ@returnꢀanꢀinteger,ꢀtheꢀnextꢀsmallestꢀnumber

ꢀꢀꢀꢀdefꢀnext(self):

ꢀꢀꢀꢀꢀꢀꢀꢀnextNodeꢀ=ꢀself.stack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀcurrentNodeꢀ=ꢀnextNode.right

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcurrentNodeꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.stack.append(currentNode)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentNodeꢀ=ꢀcurrentNode.left

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnextNode.val

#ꢀYourꢀBSTIteratorꢀwillꢀbeꢀcalledꢀlikeꢀthis:

#ꢀi,ꢀvꢀ=ꢀBSTIterator(root),ꢀ[]

#ꢀwhileꢀi.hasNext():ꢀv.append(i.next())

36





InorderꢀTraversal

InorderꢀTraversal

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀinorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ[1,null,2,3],ꢀ1ꢀ\ꢀ2ꢀ/ꢀ3ꢀreturnꢀ[1,3,2].

Note:ꢀRecursiveꢀsolutionꢀisꢀtrivial,ꢀcouldꢀyouꢀdoꢀitꢀiteratively?

URL:ꢀhttps://leetcode.com/problems/binary-tree-inorder-traversal/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[]}

ꢀꢀꢀꢀdefꢀinorderTraversal(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀorꢀnode:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(node)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀnode.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀnode.right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresult

37





InorderꢀTraversal

38





SymmetricꢀTree

SymmetricꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀcheckꢀwhetherꢀitꢀisꢀaꢀmirrorꢀofꢀitselfꢀ(ie,ꢀsymmetricꢀaroundꢀits

center).

Note:ꢀBonusꢀpointsꢀifꢀyouꢀcouldꢀsolveꢀitꢀbothꢀrecursivelyꢀandꢀiteratively.

URL:ꢀhttps://leetcode.com/problems/symmetric-tree/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisSymmetric(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.isMirror(root.left,ꢀroot.right)

ꢀꢀꢀꢀdefꢀisMirror(self,ꢀroot1,ꢀroot2):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot1ꢀ==ꢀNoneꢀandꢀroot2ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀroot1ꢀ==ꢀNoneꢀorꢀroot2ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot1.valꢀ==ꢀroot2.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.isMirror(root1.left,ꢀroot2.right)ꢀan

dꢀself.isMirror(root1.right,ꢀroot2.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

39





SymmetricꢀTree

40





BalancedꢀBinaryꢀTree

BalancedꢀBinaryꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀdetermineꢀifꢀitꢀisꢀheight-balanced.

Forꢀthisꢀproblem,ꢀaꢀheight-balancedꢀbinaryꢀtreeꢀisꢀdefinedꢀasꢀaꢀbinaryꢀtreeꢀinꢀwhich

theꢀdepthꢀofꢀtheꢀtwoꢀsubtreesꢀofꢀeveryꢀnodeꢀneverꢀdifferꢀbyꢀmoreꢀthanꢀ1.

URL:ꢀhttps://leetcode.com/problems/balanced-binary-tree/

41





BalancedꢀBinaryꢀTree

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{boolean}

ꢀꢀꢀꢀdefꢀgetHeight(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀleftHeightꢀ=ꢀself.getHeight(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀleftHeightꢀ==ꢀ-1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀꢀꢀꢀꢀrightHeightꢀ=ꢀself.getHeight(root.right)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrightHeightꢀ==ꢀ-1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀꢀꢀꢀꢀheightDiffꢀ=ꢀabs(leftHeightꢀ-ꢀrightHeight)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀheightDiffꢀ>ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax(leftHeight,rightHeight)+1

ꢀꢀꢀꢀdefꢀisBalanced(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.getHeight(root)ꢀ==ꢀ-1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

42





ClosestꢀBSTꢀValue

ClosestꢀBinaryꢀSearchꢀTreeꢀValue

Givenꢀaꢀnon-emptyꢀbinaryꢀsearchꢀtreeꢀandꢀaꢀtargetꢀvalue,ꢀfindꢀtheꢀvalueꢀinꢀthe

BSTꢀthatꢀisꢀclosestꢀtoꢀtheꢀtarget.

Note:ꢀGivenꢀtargetꢀvalueꢀisꢀaꢀfloatingꢀpoint.ꢀYouꢀareꢀguaranteedꢀtoꢀhaveꢀonlyꢀone

uniqueꢀvalueꢀinꢀtheꢀBSTꢀthatꢀisꢀclosestꢀtoꢀtheꢀtarget.

URL:ꢀhttps://leetcode.com/problems/closest-binary-search-tree-value/

43





ClosestꢀBSTꢀValue

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀclosestValue(self,ꢀroot,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀfloat

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀmin\_difꢀ=ꢀfloat("inf")

ꢀꢀꢀꢀꢀꢀꢀꢀclosestValꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀroot:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀroot\_valꢀ=ꢀroot.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀval\_difꢀ=ꢀabs(root\_valꢀ-ꢀtarget)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀval\_difꢀ<ꢀmin\_dif:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_difꢀ=ꢀval\_dif

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀclosestValꢀ=ꢀroot\_val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀtargetꢀ<ꢀroot\_val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀclosestVal

44





ClosestꢀBSTꢀValue

45





PostorderꢀTraversal

PostorderꢀTraversal

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀpostorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ{1,#,2,3},ꢀ1ꢀ\ꢀ2ꢀ/ꢀ3ꢀreturnꢀ[3,2,1].

Note:ꢀRecursiveꢀsolutionꢀisꢀtrivial,ꢀcouldꢀyouꢀdoꢀitꢀiteratively?

URL:ꢀhttps://leetcode.com/problems/binary-tree-postorder-traversal/

46





PostorderꢀTraversal

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀpostorderTraversal(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀout\_stackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀout\_stack.append(current.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀout\_stack[::-1]

47





MaximumꢀDepthꢀofꢀBinaryꢀTree

MaximumꢀDepthꢀofꢀBinaryꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀfindꢀitsꢀmaximumꢀdepth.

Theꢀmaximumꢀdepthꢀisꢀtheꢀnumberꢀofꢀnodesꢀalongꢀtheꢀlongestꢀpathꢀfromꢀtheꢀroot

nodeꢀdownꢀtoꢀtheꢀfarthestꢀleafꢀnode.

URL:ꢀhttps://leetcode.com/problems/maximum-depth-of-binary-tree/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmaxDepth(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax(self.maxDepth(root.left),ꢀself.maxDepth(r

oot.right))ꢀ+ꢀ1

48





InvertꢀBinaryꢀTree

InvertꢀBinaryꢀTree

Invertꢀaꢀbinaryꢀtree.

ꢀ4

/ꢀ\ꢀ2ꢀ7ꢀ/ꢀ\ꢀ/ꢀ\ꢀ1ꢀ3ꢀ6ꢀ9ꢀtoꢀ4ꢀ/ꢀ\ꢀ7ꢀ2ꢀ/ꢀ\ꢀ/ꢀ\ꢀ9ꢀ6ꢀ3ꢀ1ꢀTrivia:ꢀThisꢀproblemꢀwasꢀinspiredꢀbyꢀthis

originalꢀtweetꢀbyꢀMaxꢀHowell:ꢀGoogle:ꢀ90%ꢀofꢀourꢀengineersꢀuseꢀtheꢀsoftwareꢀyou

wroteꢀ(Homebrew),ꢀbutꢀyouꢀcan’tꢀinvertꢀaꢀbinaryꢀtreeꢀonꢀaꢀwhiteboardꢀsoꢀfuckꢀoff.

URL:ꢀhttps://leetcode.com/problems/invert-binary-tree/

49





InvertꢀBinaryꢀTree

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀinvertTree(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.leftꢀ!=ꢀNoneꢀorꢀcurr\_node.rightꢀ!=ꢀ

None:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀcurr\_node.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.leftꢀ=ꢀcurr\_node.right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.rightꢀ=ꢀtemp

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(curr\_node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(curr\_node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

50





SameꢀTree

SameꢀTree

Givenꢀtwoꢀbinaryꢀtrees,ꢀwriteꢀaꢀfunctionꢀtoꢀcheckꢀifꢀtheyꢀareꢀequalꢀorꢀnot.

Twoꢀbinaryꢀtreesꢀareꢀconsideredꢀequalꢀifꢀtheyꢀareꢀstructurallyꢀidenticalꢀandꢀthe

nodesꢀhaveꢀtheꢀsameꢀvalue.

URL:ꢀhttps://leetcode.com/problems/same-tree/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀp

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀq

ꢀꢀꢀꢀ#ꢀ@returnꢀ{boolean}

ꢀꢀꢀꢀdefꢀisSameTree(self,ꢀp,ꢀq):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀpꢀ==ꢀNoneꢀandꢀqꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀpꢀ==ꢀNoneꢀorꢀqꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀp.valꢀ==ꢀq.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.isSameTree(p.left,ꢀq.left)ꢀandꢀs

elf.isSameTree(p.right,ꢀq.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

51





LowestꢀCommonꢀAncestorꢀofꢀaꢀBinaryꢀSearchꢀTree

LowestꢀCommonꢀAncestorꢀofꢀaꢀBinary

SearchꢀTree

Givenꢀaꢀbinaryꢀsearchꢀtreeꢀ(BST),ꢀfindꢀtheꢀlowestꢀcommonꢀancestorꢀ(LCA)ꢀofꢀtwo

givenꢀnodesꢀinꢀtheꢀBST.

AccordingꢀtoꢀtheꢀdefinitionꢀofꢀLCAꢀonꢀWikipedia:ꢀ“Theꢀlowestꢀcommonꢀancestorꢀis

definedꢀbetweenꢀtwoꢀnodesꢀvꢀandꢀwꢀasꢀtheꢀlowestꢀnodeꢀinꢀTꢀthatꢀhasꢀbothꢀvꢀandꢀw

asꢀdescendantsꢀ(whereꢀweꢀallowꢀaꢀnodeꢀtoꢀbeꢀaꢀdescendantꢀofꢀitself).”

ꢀꢀꢀꢀ\_\_\_\_\_\_\_6\_\_\_\_\_\_

ꢀꢀꢀ/ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ\

\_\_\_2\_\_ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ\_\_\_8\_\_

/ꢀ\ꢀ/ꢀ\ꢀ0ꢀ\_4ꢀ7ꢀ9ꢀ/ꢀ\ꢀ3ꢀ5ꢀForꢀexample,ꢀtheꢀlowestꢀcommonꢀancestorꢀ(LCA)ꢀofꢀnodesꢀ2

andꢀ8ꢀisꢀ6.ꢀAnotherꢀexampleꢀisꢀLCAꢀofꢀnodesꢀ2ꢀandꢀ4ꢀisꢀ2,ꢀsinceꢀaꢀnodeꢀcanꢀbeꢀa

descendantꢀofꢀitselfꢀaccordingꢀtoꢀtheꢀLCAꢀdefinition.

URL:ꢀhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-

tree/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.inorder\_listꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀself.postorder\_listꢀ=ꢀ[]

ꢀꢀꢀꢀdefꢀlowestCommonAncestor(self,ꢀroot,ꢀp,ꢀq):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

52





LowestꢀCommonꢀAncestorꢀofꢀaꢀBinaryꢀSearchꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀp:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀq:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.inorder\_traversal(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.postorder\_traversal(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#getꢀtheꢀpositionsꢀofꢀnode1ꢀandꢀnode2ꢀinꢀtheꢀinorder

ꢀtraversalꢀofꢀtheꢀtree

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindex\_node1ꢀ=ꢀself.inorder\_list.index(p.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindex\_node2ꢀ=ꢀself.inorder\_list.index(q.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀindex\_node1ꢀ<ꢀindex\_node2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbetween\_elemsꢀ=ꢀself.inorder\_list[index\_node1ꢀ:ꢀ

index\_node2ꢀ+ꢀ1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbetween\_elemsꢀ=ꢀself.inorder\_list[index\_node2ꢀ:ꢀ

index\_node1ꢀ+ꢀ1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlca\_elemꢀ=ꢀself.find\_elem\_max\_index(between\_elems)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlca\_elem

ꢀꢀꢀꢀdefꢀfind\_elem\_max\_index(self,ꢀbetween\_elems):

ꢀꢀꢀꢀꢀꢀꢀꢀmax\_indexꢀ=ꢀ-1

ꢀꢀꢀꢀꢀꢀꢀꢀelemꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀbetween\_elems:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelem\_indexꢀ=ꢀself.postorder\_list.index(entries)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀelem\_indexꢀ>ꢀmax\_index:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_indexꢀ=ꢀelem\_index

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelemꢀ=ꢀentries

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀelem

ꢀꢀꢀꢀdefꢀinorder\_traversal(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.inorder\_traversal(node.left)

53





LowestꢀCommonꢀAncestorꢀofꢀaꢀBinaryꢀSearchꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.inorder\_list.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.inorder\_traversal(node.right)

ꢀꢀꢀꢀdefꢀpostorder\_traversal(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.postorder\_traversal(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.postorder\_traversal(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.postorder\_list.append(node.val)

54





LowestꢀCommonꢀAncestorꢀinꢀaꢀBinaryꢀTree

LowestꢀCommonꢀAncestorꢀinꢀaꢀBinaryꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀfindꢀtheꢀlowestꢀcommonꢀancestorꢀ(LCA)ꢀofꢀtwoꢀgivenꢀnodesꢀin

theꢀtree.

AccordingꢀtoꢀtheꢀdefinitionꢀofꢀLCAꢀonꢀWikipedia:ꢀ“Theꢀlowestꢀcommonꢀancestorꢀis

definedꢀbetweenꢀtwoꢀnodesꢀvꢀandꢀwꢀasꢀtheꢀlowestꢀnodeꢀinꢀTꢀthatꢀhasꢀbothꢀvꢀandꢀw

asꢀdescendantsꢀ(whereꢀweꢀallowꢀaꢀnodeꢀtoꢀbeꢀaꢀdescendantꢀofꢀitself).”

ꢀꢀꢀꢀ\_\_\_\_\_\_\_3\_\_\_\_\_\_

ꢀꢀꢀ/ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ\

\_\_\_5\_\_ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ\_\_\_1\_\_

/ꢀ\ꢀ/ꢀ\ꢀ6ꢀ\_2ꢀ0ꢀ8ꢀ/ꢀ\ꢀ7ꢀ4ꢀForꢀexample,ꢀtheꢀlowestꢀcommonꢀancestorꢀ(LCA)ꢀofꢀnodesꢀ5

andꢀ1ꢀisꢀ3.ꢀAnotherꢀexampleꢀisꢀLCAꢀofꢀnodesꢀ5ꢀandꢀ4ꢀisꢀ5,ꢀsinceꢀaꢀnodeꢀcanꢀbeꢀa

descendantꢀofꢀitselfꢀaccordingꢀtoꢀtheꢀLCAꢀdefinition.

URL:ꢀhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

55





LowestꢀCommonꢀAncestorꢀinꢀaꢀBinaryꢀTree

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀlowestCommonAncestor(self,ꢀroot,ꢀp,ꢀq):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀp:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀq:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀpꢀorꢀrootꢀ==ꢀq:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀself.lowestCommonAncestor(root.left,ꢀp,ꢀq)

ꢀꢀꢀꢀꢀꢀꢀꢀrightꢀ=ꢀself.lowestCommonAncestor(root.right,ꢀp,ꢀq)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀleftꢀ!=ꢀNoneꢀandꢀrightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀleftꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀright

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀleft

56





UniqueꢀBinaryꢀSearchꢀTrees

UniqueꢀBinaryꢀSearchꢀTrees

Givenꢀn,ꢀhowꢀmanyꢀstructurallyꢀuniqueꢀBST'sꢀ(binaryꢀsearchꢀtrees)ꢀthatꢀstore

valuesꢀ1...n?

Forꢀexample,ꢀGivenꢀnꢀ=ꢀ3,ꢀthereꢀareꢀaꢀtotalꢀofꢀ5ꢀuniqueꢀBST's.

1ꢀ3ꢀ3ꢀ2ꢀ1ꢀ\ꢀ/ꢀ/ꢀ/ꢀ\ꢀ\ꢀ3ꢀ2ꢀ1ꢀ1ꢀ3ꢀ2ꢀ/ꢀ/ꢀ\ꢀ\ꢀ2ꢀ1ꢀ2ꢀ3

URL:ꢀhttps://leetcode.com/problems/unique-binary-search-trees/

57





UniqueꢀBinaryꢀSearchꢀTrees

ꢀꢀclassꢀSolution(object):

ꢀꢀꢀꢀdefꢀnumTrees(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀsolutionsꢀ=ꢀ[-1]\*(n)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.numUniqueBST(n,ꢀsolutions)

ꢀꢀꢀꢀdefꢀnumUniqueBST(self,ꢀn,ꢀsolutions):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ0ꢀorꢀnꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀpossibilitiesꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀsolutions[i]ꢀ==ꢀ-1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsolutions[i]ꢀ=ꢀself.numUniqueBST(i,ꢀsolutions)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀsolutions[n-1-i]ꢀ==ꢀ-1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsolutions[n-1-i]ꢀ=ꢀself.numUniqueBST(n-1-i,ꢀsolu

tions)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpossibilitiesꢀ+=ꢀsolutions[i]\*solutions[n-1-i]

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀpossibilities

58





UniqueꢀBinaryꢀSearchꢀTreesꢀII

UniqueꢀBinaryꢀSearchꢀTreesꢀII

Givenꢀanꢀintegerꢀn,ꢀgenerateꢀallꢀstructurallyꢀuniqueꢀBST'sꢀ(binaryꢀsearchꢀtrees)

thatꢀstoreꢀvaluesꢀ1...n.

Forꢀexample,ꢀGivenꢀnꢀ=ꢀ3,ꢀyourꢀprogramꢀshouldꢀreturnꢀallꢀ5ꢀuniqueꢀBST'sꢀshown

below.

1ꢀ3ꢀ3ꢀ2ꢀ1ꢀ\ꢀ/ꢀ/ꢀ/ꢀ\ꢀ\ꢀ3ꢀ2ꢀ1ꢀ1ꢀ3ꢀ2ꢀ/ꢀ/ꢀ\ꢀ\ꢀ2ꢀ1ꢀ2ꢀ3

URL:ꢀhttps://leetcode.com/problems/unique-binary-search-trees-ii/

59





UniqueꢀBinaryꢀSearchꢀTreesꢀII

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgenerateTrees(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[TreeNode]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.tree\_constructor(1,ꢀn)

ꢀꢀꢀꢀdefꢀtree\_constructor(self,ꢀm,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀresultsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmꢀ>ꢀn:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresults.append(None)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresults

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(m,ꢀn+1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlꢀ=ꢀself.tree\_constructor(m,ꢀi-1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ=ꢀself.tree\_constructor(i+1,ꢀn)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀleft\_treesꢀinꢀl:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀright\_treesꢀinꢀr:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀTreeNode(i)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.leftꢀ=ꢀleft\_trees

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.rightꢀ=ꢀright\_trees

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresults.append(curr\_node)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresults

60





UniqueꢀBinaryꢀSearchꢀTreesꢀII

61





PathꢀSum

PathꢀSum

Givenꢀaꢀbinaryꢀtreeꢀandꢀaꢀsum,ꢀdetermineꢀifꢀtheꢀtreeꢀhasꢀaꢀroot-to-leafꢀpathꢀsuch

thatꢀaddingꢀupꢀallꢀtheꢀvaluesꢀalongꢀtheꢀpathꢀequalsꢀtheꢀgivenꢀsum.

Forꢀexample:ꢀGivenꢀtheꢀbelowꢀbinaryꢀtreeꢀandꢀsumꢀ=ꢀ22,ꢀ5ꢀ/ꢀ\ꢀ4ꢀ8ꢀ/ꢀ/ꢀ\ꢀ11ꢀ13ꢀ4ꢀ/ꢀ\ꢀ\ꢀ7

2ꢀ1ꢀreturnꢀtrue,ꢀasꢀthereꢀexistꢀaꢀroot-to-leafꢀpathꢀ5->4->11->2ꢀwhichꢀsumꢀisꢀ22.

URL:ꢀhttps://leetcode.com/problems/path-sum/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀhasPathSum(self,ꢀroot,ꢀsum):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀsum:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀsꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathsumꢀ=ꢀs.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀs.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀcurrent.leftꢀandꢀnotꢀcurrent.right:

62





PathꢀSum

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀpathsumꢀ==ꢀsum:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightpathsumꢀ=ꢀpathsumꢀ+ꢀcurrent.right.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(rightpathsum)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftpathsumꢀ=ꢀpathsumꢀ+ꢀcurrent.left.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(leftpathsum)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

63





BinaryꢀTreeꢀMaximumꢀPathꢀSum

BinaryꢀTreeꢀMaximumꢀPathꢀSum

Givenꢀaꢀbinaryꢀtree,ꢀfindꢀtheꢀmaximumꢀpathꢀsum.

Forꢀthisꢀproblem,ꢀaꢀpathꢀisꢀdefinedꢀasꢀanyꢀsequenceꢀofꢀnodesꢀfromꢀsomeꢀstarting

nodeꢀtoꢀanyꢀnodeꢀinꢀtheꢀtreeꢀalongꢀtheꢀparent-childꢀconnections.ꢀTheꢀpathꢀdoes

notꢀneedꢀtoꢀgoꢀthroughꢀtheꢀroot.

Forꢀexample:ꢀGivenꢀtheꢀbelowꢀbinaryꢀtree,

ꢀꢀꢀ1

ꢀꢀ/ꢀ\

ꢀ2ꢀꢀꢀ3

Returnꢀ6

URL:ꢀhttps://leetcode.com/problems/binary-tree-maximum-path-sum/

64





BinaryꢀTreeꢀMaximumꢀPathꢀSum

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.maxSumꢀ=ꢀ-sys.maxintꢀ-ꢀ1

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer}

ꢀꢀꢀꢀdefꢀmaxPathSum(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀself.findMax(root)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.maxSum

ꢀꢀꢀꢀdefꢀfindMax(self,root):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀself.findMax(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀrightꢀ=ꢀself.findMax(root.right)

ꢀꢀꢀꢀꢀꢀꢀꢀself.maxSumꢀ=ꢀmax(root.valꢀ+ꢀleftꢀ+ꢀright,ꢀself.maxSum)

ꢀꢀꢀꢀꢀꢀꢀꢀretꢀ=ꢀroot.valꢀ+ꢀmax(left,right)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀretꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀret

65





BinaryꢀTreeꢀLevelꢀOrderꢀTraversal

BinaryꢀTreeꢀLevelꢀOrderꢀTraversal

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀlevelꢀorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.ꢀ(ie,ꢀfrom

leftꢀtoꢀright,ꢀlevelꢀbyꢀlevel).

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ[3,9,20,null,null,15,7],ꢀ3ꢀ/ꢀ\ꢀ9ꢀ20ꢀ/ꢀ\ꢀ15ꢀ7ꢀreturnꢀits

levelꢀorderꢀtraversalꢀas:ꢀ[ꢀ[3],ꢀ[9,20],ꢀ[15,7]ꢀ]

URL:ꢀhttps://leetcode.com/problems/binary-tree-level-order-traversal/

66





BinaryꢀTreeꢀLevelꢀOrderꢀTraversal

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

importꢀQueue

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[][]}

ꢀꢀꢀꢀdefꢀlevelOrder(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀqꢀ=ꢀQueue.Queue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversalꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀq.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ==ꢀ"#":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversal.append(level)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevel.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlevelOrderTraversal

67





ValidateꢀBinaryꢀSearchꢀTree

ValidateꢀBinaryꢀSearchꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀdetermineꢀifꢀitꢀisꢀaꢀvalidꢀbinaryꢀsearchꢀtreeꢀ(BST).

AssumeꢀaꢀBSTꢀisꢀdefinedꢀasꢀfollows:

Theꢀleftꢀsubtreeꢀofꢀaꢀnodeꢀcontainsꢀonlyꢀnodesꢀwithꢀkeysꢀlessꢀthanꢀtheꢀnode'sꢀkey.

Theꢀrightꢀsubtreeꢀofꢀaꢀnodeꢀcontainsꢀonlyꢀnodesꢀwithꢀkeysꢀgreaterꢀthanꢀtheꢀnode's

key.ꢀBothꢀtheꢀleftꢀandꢀrightꢀsubtreesꢀmustꢀalsoꢀbeꢀbinaryꢀsearchꢀtrees.ꢀExampleꢀ1:

2ꢀ/ꢀ\ꢀ1ꢀ3ꢀBinaryꢀtreeꢀ[2,1,3],ꢀreturnꢀtrue.ꢀExampleꢀ2:ꢀ1ꢀ/ꢀ\ꢀ2ꢀ3ꢀBinaryꢀtreeꢀ[1,2,3],

returnꢀfalse.

URL:ꢀhttps://leetcode.com/problems/validate-binary-search-tree/

68





ValidateꢀBinaryꢀSearchꢀTree

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

importꢀsys

classꢀSolution:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.lastPrintedꢀ=ꢀ-sys.maxsize-1

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{boolean}

ꢀꢀꢀꢀdefꢀisValidBST(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.isValidBST(root.left)ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀdataꢀ=ꢀroot.val

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀdataꢀ<=ꢀself.lastPrinted:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀself.lastPrintedꢀ=ꢀdata

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.isValidBST(root.right)ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

69





MinimumꢀDepthꢀofꢀBinaryꢀTree

MinimumꢀDepthꢀofꢀBinaryꢀTree

Givenꢀaꢀbinaryꢀtree,ꢀfindꢀitsꢀminimumꢀdepth.

Theꢀminimumꢀdepthꢀisꢀtheꢀnumberꢀofꢀnodesꢀalongꢀtheꢀshortestꢀpathꢀfromꢀtheꢀroot

nodeꢀdownꢀtoꢀtheꢀnearestꢀleafꢀnode.

URL:ꢀhttps://leetcode.com/problems/minimum-depth-of-binary-tree/

70





MinimumꢀDepthꢀofꢀBinaryꢀTree

importꢀsys

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀminDepth(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.leftꢀ==ꢀNoneꢀandꢀroot.rightꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀself.minDepth(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightꢀ=ꢀself.minDepth(root.right)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1ꢀ+ꢀmin(left,ꢀright)

71





ConvertꢀSortedꢀArrayꢀtoꢀBinaryꢀSearchꢀTree

ConvertꢀSortedꢀArrayꢀtoꢀBinaryꢀSearch

Tree

Givenꢀanꢀarrayꢀwhereꢀelementsꢀareꢀsortedꢀinꢀascendingꢀorder,ꢀconvertꢀitꢀtoꢀa

heightꢀbalancedꢀBST.

URL:ꢀhttps://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

72





ConvertꢀSortedꢀArrayꢀtoꢀBinaryꢀSearchꢀTree

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsortedArrayToBST(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnumsꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTreeNode(nums[0])

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(nums)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.to\_bst(nums,ꢀstart,ꢀend)

ꢀꢀꢀꢀdefꢀto\_bst(self,ꢀarr,ꢀstart,ꢀend):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(arr)ꢀ==ꢀ0ꢀorꢀstartꢀ>ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmidꢀ=ꢀ(startꢀ+ꢀend)ꢀ//ꢀ2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀTreeNode(arr[mid])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode.leftꢀ=ꢀself.to\_bst(arr,ꢀstart,ꢀmidꢀ-ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode.rightꢀ=ꢀself.to\_bst(arr,ꢀmidꢀ+ꢀ1,ꢀend)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnode`

73





FlattenꢀBinaryꢀTreeꢀtoꢀLinkedꢀList

FlattenꢀBinaryꢀTreeꢀtoꢀLinkedꢀList

Givenꢀaꢀbinaryꢀtree,ꢀflattenꢀitꢀtoꢀaꢀlinkedꢀlistꢀin-place.

Forꢀexample,ꢀGiven

ꢀꢀꢀꢀꢀ1

ꢀꢀꢀꢀ/ꢀ\

ꢀꢀꢀ2ꢀꢀꢀ5

ꢀꢀ/ꢀ\ꢀꢀꢀ\

ꢀ3ꢀꢀꢀ4ꢀꢀꢀ6

Theꢀflattenedꢀtreeꢀshouldꢀlookꢀlike:ꢀ1ꢀ\ꢀ2ꢀ\ꢀ3ꢀ\ꢀ4ꢀ\ꢀ5ꢀ\ꢀ6

URL:ꢀhttps://leetcode.com/problems/flatten-binary-tree-to-linked-list/

74





FlattenꢀBinaryꢀTreeꢀtoꢀLinkedꢀList

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀflatten(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀrootꢀin-plac

eꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀwhile((stackꢀ!=ꢀ[])ꢀorꢀ(currentꢀ!=ꢀNone)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrent.rightꢀ=ꢀcurrent.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrent.leftꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrent.rightꢀ=ꢀtemp

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀcurrent.right

75





ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPreorderꢀTraversal

ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀand

PreorderꢀTraversal

Givenꢀpreorderꢀandꢀinorderꢀtraversalꢀofꢀaꢀtree,ꢀconstructꢀtheꢀbinaryꢀtree.

Note:ꢀYouꢀmayꢀassumeꢀthatꢀduplicatesꢀdoꢀnotꢀexistꢀinꢀtheꢀtree.

URL:ꢀhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-

inorder-traversal/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀbuildTree(self,ꢀpreorder,ꢀinorder):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀpreorder:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀinorder:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(inorder)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTreeNode(inorder[0])

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.create\_tree(inorder,ꢀ0,ꢀlen(inorder)ꢀ-ꢀ1,ꢀpr

eorder,ꢀ0,ꢀlen(preorder)ꢀ-ꢀ1)

ꢀꢀꢀꢀdefꢀsearch\_divindex(self,ꢀinorder,ꢀlow\_inorder,ꢀhigh\_inorder

,ꢀval):

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(low\_inorder,ꢀhigh\_inorder+1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀinorder[i]ꢀ==ꢀval:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀdefꢀcreate\_tree(self,ꢀinorder,ꢀlow\_inorder,ꢀhigh\_inorder,ꢀpr

eorder,ꢀlow\_preorder,ꢀhigh\_preorder):

76





ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPreorderꢀTraversal

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(low\_preorderꢀ>ꢀhigh\_preorder)ꢀorꢀ(low\_inorderꢀ>ꢀhigh

\_inorder):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀTreeNode(preorder[low\_preorder])

ꢀꢀꢀꢀꢀꢀꢀꢀdiv\_indexꢀ=ꢀself.search\_divindex(inorder,ꢀlow\_inorder,ꢀh

igh\_inorder,ꢀroot.val)

ꢀꢀꢀꢀꢀꢀꢀꢀsize\_left\_subtreeꢀ=ꢀdiv\_indexꢀ-ꢀlow\_inorder

ꢀꢀꢀꢀꢀꢀꢀꢀsize\_right\_subtreeꢀ=ꢀhigh\_inorderꢀ-ꢀdiv\_index

ꢀꢀꢀꢀꢀꢀꢀꢀroot.rightꢀ=ꢀself.create\_tree(inorder,ꢀdiv\_indexꢀ+ꢀ1,ꢀhi

gh\_inorder,ꢀpreorder,ꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlow\_preorderꢀ+ꢀ1ꢀ+ꢀsize\_le

ft\_subtree,

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlow\_preorderꢀ+ꢀsize\_left\_s

ubtreeꢀ+ꢀsize\_right\_subtree)

ꢀꢀꢀꢀꢀꢀꢀꢀroot.leftꢀ=ꢀself.create\_tree(inorder,ꢀlow\_inorder,ꢀdiv\_i

ndexꢀ-ꢀ1,ꢀpreorder,

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlow\_preorderꢀ+ꢀ1,ꢀlow\_preor

derꢀ+ꢀsize\_left\_subtree)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

77





BinaryꢀTreeꢀPaths

BinaryꢀTreeꢀPaths

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀallꢀroot-to-leafꢀpaths.

Forꢀexample,ꢀgivenꢀtheꢀfollowingꢀbinaryꢀtree:

1ꢀ/ꢀ\ꢀ2ꢀ3ꢀ\ꢀ5ꢀAllꢀroot-to-leafꢀpathsꢀare:

["1->2->5",ꢀ"1->3"]

URL:ꢀhttps://leetcode.com/problems/binary-tree-paths/

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{string[]}

ꢀꢀꢀꢀdefꢀbinaryTreePaths(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(str(current.val))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀsꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#pathsumꢀ=ꢀs.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathꢀ=ꢀs.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀs.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀcurrent.leftꢀandꢀnotꢀcurrent.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpaths.append(path)

78





BinaryꢀTreeꢀPaths

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightstrꢀ=ꢀpathꢀ+ꢀ"->"ꢀ+ꢀstr(current.right.v

al)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(rightstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftstrꢀ=ꢀpathꢀ+ꢀ"->"ꢀ+ꢀstr(current.left.val

)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(current.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs.append(leftstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀpaths

79





RecoverꢀBinaryꢀSearchꢀTree

RecoverꢀBinaryꢀSearchꢀTree

Twoꢀelementsꢀofꢀaꢀbinaryꢀsearchꢀtreeꢀ(BST)ꢀareꢀswappedꢀbyꢀmistake.

Recoverꢀtheꢀtreeꢀwithoutꢀchangingꢀitsꢀstructure.

Note:ꢀAꢀsolutionꢀusingꢀO(n)ꢀspaceꢀisꢀprettyꢀstraightꢀforward.ꢀCouldꢀyouꢀdeviseꢀa

constantꢀspaceꢀsolution?

URL:ꢀhttps://leetcode.com/problems/recover-binary-search-tree/

80





RecoverꢀBinaryꢀSearchꢀTree

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_prevꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node1ꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node2ꢀ=ꢀNone

ꢀꢀꢀꢀdefꢀrecoverTree(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀrootꢀin-plac

eꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.recoverTreeHelp(root)ꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀself.\_\_node1.val

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node1.valꢀ=ꢀself.\_\_node2.val

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node2.valꢀ=ꢀtemp

ꢀꢀꢀꢀdefꢀrecoverTreeHelp(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀself.recoverTreeHelp(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.\_\_prevꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.\_\_prev.valꢀ>ꢀroot.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.\_\_node1ꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node1ꢀ=ꢀself.\_\_prev

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_node2ꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_prevꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀself.recoverTreeHelp(root.right)

81





PathꢀSumꢀII

PathꢀSumꢀII

Givenꢀaꢀbinaryꢀtreeꢀandꢀaꢀsum,ꢀfindꢀallꢀroot-to-leafꢀpathsꢀwhereꢀeachꢀpath'sꢀsum

equalsꢀtheꢀgivenꢀsum.

Forꢀexample:ꢀGivenꢀtheꢀbelowꢀbinaryꢀtreeꢀandꢀsumꢀ=ꢀ22,ꢀ5ꢀ/ꢀ\ꢀ4ꢀ8ꢀ/ꢀ/ꢀ\ꢀ11ꢀ13ꢀ4ꢀ/ꢀ\ꢀ/ꢀ\

7ꢀ2ꢀ5ꢀ1ꢀreturnꢀ[ꢀ[5,4,11,2],ꢀ[5,8,4,5]ꢀ]

URL:ꢀhttps://leetcode.com/problems/path-sum-ii/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀpathSum(self,ꢀroot,ꢀsum):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀsum:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append([current.val])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathsumꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrꢀ=ꢀstack.pop()

82





PathꢀSumꢀII

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr.leftꢀ==ꢀNoneꢀandꢀcurr.rightꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀpathsumꢀ==ꢀsum:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpaths.append(path)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightstrꢀ=ꢀpathꢀ+ꢀ[curr.right.val]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightsumꢀ=ꢀpathsumꢀ+ꢀcurr.right.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(curr.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(rightstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(rightsum)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftstrꢀ=ꢀpathꢀ+ꢀ[curr.left.val]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftsumꢀ=ꢀpathsumꢀ+ꢀcurr.left.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(curr.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(leftstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(leftsum)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀpaths

83





BinaryꢀLevelꢀOrderꢀTraversalꢀII

BinaryꢀLevelꢀOrderꢀTraversalꢀII

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀbottom-upꢀlevelꢀorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.

(ie,ꢀfromꢀleftꢀtoꢀright,ꢀlevelꢀbyꢀlevelꢀfromꢀleafꢀtoꢀroot).

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ[3,9,20,null,null,15,7],ꢀ3ꢀ/ꢀ\ꢀ9ꢀ20ꢀ/ꢀ\ꢀ15ꢀ7ꢀreturnꢀits

bottom-upꢀlevelꢀorderꢀtraversalꢀas:ꢀ[ꢀ[15,7],ꢀ[9,20],ꢀ[3]ꢀ]

URL:ꢀhttps://leetcode.com/problems/binary-tree-level-order-traversal-ii/

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

importꢀQueue

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[][]}

ꢀꢀꢀꢀdefꢀlevelOrderBottom(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀqꢀ=ꢀQueue.Queue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversalꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀq.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ==ꢀ"#":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(level)

84





BinaryꢀLevelꢀOrderꢀTraversalꢀII

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevel.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstack:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversal.append(stack.pop())

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlevelOrderTraversal

85





KthꢀSmallestꢀElementꢀinꢀaꢀBST

KthꢀSmallestꢀElementꢀinꢀaꢀBST

Givenꢀaꢀbinaryꢀsearchꢀtree,ꢀwriteꢀaꢀfunctionꢀkthSmallestꢀtoꢀfindꢀtheꢀkthꢀsmallest

elementꢀinꢀit.

Note:ꢀYouꢀmayꢀassumeꢀkꢀisꢀalwaysꢀvalid,ꢀ1ꢀ≤ꢀkꢀ≤ꢀBST'sꢀtotalꢀelements.

Followꢀup:ꢀWhatꢀifꢀtheꢀBSTꢀisꢀmodifiedꢀ(insert/deleteꢀoperations)ꢀoftenꢀandꢀyou

needꢀtoꢀfindꢀtheꢀkthꢀsmallestꢀfrequently?ꢀHowꢀwouldꢀyouꢀoptimizeꢀtheꢀkthSmallest

routine?

Hint:

TryꢀtoꢀutilizeꢀtheꢀpropertyꢀofꢀaꢀBST.ꢀWhatꢀifꢀyouꢀcouldꢀmodifyꢀtheꢀBSTꢀnode's

structure?ꢀTheꢀoptimalꢀruntimeꢀcomplexityꢀisꢀO(heightꢀofꢀBST).

URL:ꢀhttps://leetcode.com/problems/kth-smallest-element-in-a-bst/

86





KthꢀSmallestꢀElementꢀinꢀaꢀBST

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀkthSmallest(self,ꢀroot,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstack!=ꢀ[]ꢀorꢀnodeꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(node)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀnode.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀinorder\_nodeꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcountꢀ==ꢀk:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀinorder\_node.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀinorder\_node.right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

87





KthꢀSmallestꢀElementꢀinꢀaꢀBST

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀkthSmallest(self,ꢀroot,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]\*k

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀTrue:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀroot:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀkꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot.val

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.right

88





ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPostorderꢀTraversal

ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀand

PostorderꢀTraversal

Givenꢀinorderꢀandꢀpostorderꢀtraversalꢀofꢀaꢀtree,ꢀconstructꢀtheꢀbinaryꢀtree.

Note:ꢀYouꢀmayꢀassumeꢀthatꢀduplicatesꢀdoꢀnotꢀexistꢀinꢀtheꢀtree.

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀbuildTree(self,ꢀinorder,ꢀpostorder):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀinorder:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀpostorder:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.create\_tree(inorder,ꢀ0,ꢀlen(inorder)ꢀ-1ꢀ,ꢀpo

storder,ꢀ0,ꢀlen(postorder)ꢀ-ꢀ1)

ꢀꢀꢀꢀdefꢀsearch\_divindex(self,ꢀinorder,ꢀlow\_inorder,ꢀhigh\_inorder

,ꢀval):

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(low\_inorder,ꢀhigh\_inorder+1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀinorder[i]ꢀ==ꢀval:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀdefꢀcreate\_tree(self,ꢀinorder,ꢀlow\_inorder,ꢀhigh\_inorder,ꢀpo

storder,ꢀlow\_postorder,ꢀhigh\_postorder):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(low\_inorderꢀ>ꢀhigh\_inorder)ꢀorꢀ(low\_postorderꢀ>ꢀhigh

\_postorder):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

89





ConstructꢀBinaryꢀTreeꢀfromꢀInorderꢀandꢀPostorderꢀTraversal

ꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀTreeNode(postorder[high\_postorder])

ꢀꢀꢀꢀꢀꢀꢀꢀdiv\_indexꢀ=ꢀself.search\_divindex(inorder,ꢀlow\_inorder,ꢀh

igh\_inorder,ꢀroot.val)

ꢀꢀꢀꢀꢀꢀꢀꢀsize\_left\_subtreeꢀ=ꢀdiv\_indexꢀ-ꢀlow\_inorder

ꢀꢀꢀꢀꢀꢀꢀꢀsize\_right\_subtreeꢀ=ꢀhigh\_inorderꢀ-ꢀdiv\_index

ꢀꢀꢀꢀꢀꢀꢀꢀroot.rightꢀ=ꢀself.create\_tree(inorder,ꢀdiv\_indexꢀ+ꢀ1,ꢀhi

gh\_inorder,ꢀpostorder,ꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhigh\_postorderꢀ-ꢀsize\_righ

t\_subtree,ꢀhigh\_postorderꢀ-ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀroot.leftꢀ=ꢀself.create\_tree(inorder,ꢀlow\_inorder,ꢀdiv\_i

ndexꢀ-ꢀ1,

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpostorder,

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhigh\_postorderꢀ-ꢀsize\_right

\_subtreeꢀ-ꢀsize\_left\_subtree,

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀhigh\_postorderꢀ-ꢀsize\_right

\_subtreeꢀ-ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

90





BinaryꢀTreeꢀRightꢀSideꢀView

BinaryꢀTreeꢀRightꢀSideꢀView

Givenꢀaꢀbinaryꢀtree,ꢀimagineꢀyourselfꢀstandingꢀonꢀtheꢀrightꢀsideꢀofꢀit,ꢀreturnꢀthe

valuesꢀofꢀtheꢀnodesꢀyouꢀcanꢀseeꢀorderedꢀfromꢀtopꢀtoꢀbottom.

Forꢀexample:ꢀGivenꢀtheꢀfollowingꢀbinaryꢀtree,ꢀ1ꢀ<---ꢀ/ꢀ\ꢀ2ꢀ3ꢀ<---ꢀ\ꢀ\ꢀ5ꢀ4ꢀ<---ꢀYou

shouldꢀreturnꢀ[1,ꢀ3,ꢀ4].

URL:ꢀhttps://leetcode.com/problems/binary-tree-right-side-view/

91





BinaryꢀTreeꢀRightꢀSideꢀView

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

importꢀQueue

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[]}

ꢀꢀꢀꢀdefꢀrightSideView(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀqꢀ=ꢀQueue.Queue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightSideViewꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀq.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ==ꢀ"#":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightSideView.append(level[-1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevel.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.rightꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀrightSideView

92





SumꢀRootꢀtoꢀLeafꢀNumbers

SumꢀRootꢀtoꢀLeafꢀNumbers

Givenꢀaꢀbinaryꢀtreeꢀcontainingꢀdigitsꢀfromꢀ0-9ꢀonly,ꢀeachꢀroot-to-leafꢀpathꢀcould

representꢀaꢀnumber.

Anꢀexampleꢀisꢀtheꢀroot-to-leafꢀpathꢀ1->2->3ꢀwhichꢀrepresentsꢀtheꢀnumberꢀ123.

Findꢀtheꢀtotalꢀsumꢀofꢀallꢀroot-to-leafꢀnumbers.

Forꢀexample,

1

/ꢀ\ꢀ2ꢀ3ꢀTheꢀroot-to-leafꢀpathꢀ1->2ꢀrepresentsꢀtheꢀnumberꢀ12.ꢀTheꢀroot-to-leafꢀpath

1->3ꢀrepresentsꢀtheꢀnumberꢀ13.

Returnꢀtheꢀsumꢀ=ꢀ12ꢀ+ꢀ13ꢀ=ꢀ25.

93





SumꢀRootꢀtoꢀLeafꢀNumbers

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsumNumbers(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(str(root.val))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpathꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrentꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.leftꢀ==ꢀNoneꢀandꢀcurrent.rightꢀ==ꢀNon

e:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpaths.append(int(path))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrightstrꢀ=ꢀpathꢀ+ꢀstr(current.right.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(rightstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurrent.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftstrꢀ=ꢀpathꢀ+ꢀstr(current.left.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(current.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(leftstr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀsum(paths)

94





BinaryꢀTreeꢀZigzagꢀLevelꢀOrderꢀTraversal

BinaryꢀTreeꢀZigzagꢀLevelꢀOrderꢀTraversal

Givenꢀaꢀbinaryꢀtree,ꢀreturnꢀtheꢀzigzagꢀlevelꢀorderꢀtraversalꢀofꢀitsꢀnodes'ꢀvalues.ꢀ(ie,

fromꢀleftꢀtoꢀright,ꢀthenꢀrightꢀtoꢀleftꢀforꢀtheꢀnextꢀlevelꢀandꢀalternateꢀbetween).

Forꢀexample:ꢀGivenꢀbinaryꢀtreeꢀ[3,9,20,null,null,15,7],ꢀ3ꢀ/ꢀ\ꢀ9ꢀ20ꢀ/ꢀ\ꢀ15ꢀ7ꢀreturnꢀits

zigzagꢀlevelꢀorderꢀtraversalꢀas:ꢀ[ꢀ[3],ꢀ[20,9],ꢀ[15,7]ꢀ]

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode:

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

importꢀQueue

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{TreeNode}ꢀroot

ꢀꢀꢀꢀ#ꢀ@returnꢀ{integer[][]}

ꢀꢀꢀꢀdefꢀzigzagLevelOrder(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀqꢀ=ꢀQueue.Queue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversalꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelNoꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodeꢀ=ꢀq.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnodeꢀ==ꢀ"#":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put("#")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlevelNoꢀ==ꢀ0ꢀorꢀlevelNoꢀ%ꢀ2ꢀ==ꢀ0:ꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversal.append(level)

95





BinaryꢀTreeꢀZigzagꢀLevelꢀOrderꢀTraversal

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelOrderTraversal.append(level[::-1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevelNoꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlevel.append(node.val)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlevelOrderTraversal

96





HouseꢀRobberꢀIII

HouseꢀRobberꢀIII

Theꢀthiefꢀhasꢀfoundꢀhimselfꢀaꢀnewꢀplaceꢀforꢀhisꢀthieveryꢀagain.ꢀThereꢀisꢀonlyꢀone

entranceꢀtoꢀthisꢀarea,ꢀcalledꢀtheꢀ"root."ꢀBesidesꢀtheꢀroot,ꢀeachꢀhouseꢀhasꢀoneꢀand

onlyꢀoneꢀparentꢀhouse.ꢀAfterꢀaꢀtour,ꢀtheꢀsmartꢀthiefꢀrealizedꢀthatꢀ"allꢀhousesꢀinꢀthis

placeꢀformsꢀaꢀbinaryꢀtree".ꢀItꢀwillꢀautomaticallyꢀcontactꢀtheꢀpoliceꢀifꢀtwoꢀdirectly-

linkedꢀhousesꢀwereꢀbrokenꢀintoꢀonꢀtheꢀsameꢀnight.

Determineꢀtheꢀmaximumꢀamountꢀofꢀmoneyꢀtheꢀthiefꢀcanꢀrobꢀtonightꢀwithout

alertingꢀtheꢀpolice.

Exampleꢀ1:ꢀ3ꢀ/ꢀ\ꢀ2ꢀ3ꢀ\ꢀ\ꢀ3ꢀ1ꢀMaximumꢀamountꢀofꢀmoneyꢀtheꢀthiefꢀcanꢀrobꢀ=ꢀ3ꢀ+ꢀ3ꢀ+

1ꢀ=ꢀ7.ꢀExampleꢀ2:ꢀ3ꢀ/ꢀ\ꢀ4ꢀ5ꢀ/ꢀ\ꢀ\ꢀ1ꢀ3ꢀ1ꢀMaximumꢀamountꢀofꢀmoneyꢀtheꢀthiefꢀcanꢀrob

=ꢀ4ꢀ+ꢀ5ꢀ=ꢀ9.

URL:ꢀhttps://leetcode.com/problems/house-robber-iii/

97





HouseꢀRobberꢀIII

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀrob(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀself.rob\_max(root)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax(result[0],ꢀresult[1])

ꢀꢀꢀꢀdefꢀrob\_max(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[0,ꢀ0]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleft\_resꢀ=ꢀself.rob\_max(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀright\_resꢀ=ꢀself.rob\_max(root.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ[0]\*2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult[0]ꢀ=ꢀroot.valꢀ+ꢀleft\_res[1]ꢀ+ꢀright\_res[1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult[1]ꢀ=ꢀmax(left\_res[0],ꢀleft\_res[1])ꢀ+ꢀmax(righ

t\_res[0],ꢀright\_res[1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresult

98





InorderꢀSuccessorꢀinꢀBST

InorderꢀSuccessorꢀinꢀBST

Givenꢀaꢀbinaryꢀsearchꢀtreeꢀandꢀaꢀnodeꢀinꢀit,ꢀfindꢀtheꢀin-orderꢀsuccessorꢀofꢀthat

nodeꢀinꢀtheꢀBST.

Note:ꢀIfꢀtheꢀgivenꢀnodeꢀhasꢀnoꢀin-orderꢀsuccessorꢀinꢀtheꢀtree,ꢀreturnꢀnull.

URL:ꢀhttps://leetcode.com/problems/inorder-successor-in-bst/

99





InorderꢀSuccessorꢀinꢀBST

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀinorderSuccessor(self,ꢀroot,ꢀp):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀp:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀsuccessorꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀrootꢀ!=ꢀNoneꢀandꢀroot.valꢀ!=ꢀp.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.valꢀ>ꢀp.val:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsuccessorꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.right

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.rightꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀsuccessor

ꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.right

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀroot.leftꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀroot.left

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀroot

100





BinaryꢀTreeꢀLongestꢀConsecutiveꢀSequence

BinaryꢀTreeꢀLongestꢀConsecutive

Sequence

Givenꢀaꢀbinaryꢀtree,ꢀfindꢀtheꢀlengthꢀofꢀtheꢀlongestꢀconsecutiveꢀsequenceꢀpath.

Theꢀpathꢀrefersꢀtoꢀanyꢀsequenceꢀofꢀnodesꢀfromꢀsomeꢀstartingꢀnodeꢀtoꢀanyꢀnodeꢀin

theꢀtreeꢀalongꢀtheꢀparent-childꢀconnections.ꢀTheꢀlongestꢀconsecutiveꢀpathꢀneedꢀto

beꢀfromꢀparentꢀtoꢀchildꢀ(cannotꢀbeꢀtheꢀreverse).

Forꢀexample,ꢀ1ꢀ\ꢀ3ꢀ/ꢀ\ꢀ2ꢀ4ꢀ\ꢀ5ꢀLongestꢀconsecutiveꢀsequenceꢀpathꢀisꢀ3-4-5,ꢀso

returnꢀ3.ꢀ2ꢀ\ꢀ3ꢀ/ꢀ2

/ꢀ1ꢀLongestꢀconsecutiveꢀsequenceꢀpathꢀisꢀ2-3,not3-2-1,ꢀsoꢀreturnꢀ2.

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

fromꢀQueueꢀimportꢀQueue

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀlongestConsecutive(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.rightꢀ==ꢀNoneꢀandꢀroot.leftꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_sizeꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsize\_qꢀ=ꢀQueue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode\_qꢀ=ꢀQueue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode\_q.put(root)

101





BinaryꢀTreeꢀLongestꢀConsecutiveꢀSequence

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsize\_q.put(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀnode\_q.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀnode\_q.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sizeꢀ=ꢀsize\_q.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.left:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleft\_sizeꢀ=ꢀcurr\_size

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.valꢀ==ꢀcurr\_node.left.valꢀ-ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleft\_sizeꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_sizeꢀ=ꢀmax(max\_size,ꢀleft\_size)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleft\_sizeꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode\_q.put(curr\_node.left)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsize\_q.put(left\_size)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.right:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀright\_sizeꢀ=ꢀcurr\_size

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_node.valꢀ==ꢀcurr\_node.right.valꢀ-ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀright\_sizeꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_sizeꢀ=ꢀmax(max\_size,ꢀright\_size)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀright\_sizeꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnode\_q.put(curr\_node.right)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsize\_q.put(right\_size)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax\_size

102





VerifyꢀPreorderꢀSequenceꢀinꢀBinaryꢀSearchꢀTree

VerifyꢀPreorderꢀSequenceꢀinꢀBinaryꢀSearch

Tree

Givenꢀanꢀarrayꢀofꢀnumbers,ꢀverifyꢀwhetherꢀitꢀisꢀtheꢀcorrectꢀpreorderꢀtraversal

sequenceꢀofꢀaꢀbinaryꢀsearchꢀtree.

Youꢀmayꢀassumeꢀeachꢀnumberꢀinꢀtheꢀsequenceꢀisꢀunique.

Followꢀup:ꢀCouldꢀyouꢀdoꢀitꢀusingꢀonlyꢀconstantꢀspaceꢀcomplexity?

URL:ꢀhttps://leetcode.com/problems/verify-preorder-sequence-in-binary-search-

tree/

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀverifyPreorder(self,ꢀpreorder):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀpreorder:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀ-sys.maxsize-1

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀpreorder:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀentriesꢀ<ꢀroot:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]ꢀandꢀstack[-1]ꢀ<ꢀentries:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrootꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(entries)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

103





VerifyꢀPreorderꢀSequenceꢀinꢀBinaryꢀSearchꢀTree

104





BinaryꢀTreeꢀUpsideꢀDown

BinaryꢀTreeꢀUpsideꢀDown

Givenꢀaꢀbinaryꢀtreeꢀwhereꢀallꢀtheꢀrightꢀnodesꢀareꢀeitherꢀleafꢀnodesꢀwithꢀaꢀsiblingꢀ(a

leftꢀnodeꢀthatꢀsharesꢀtheꢀsameꢀparentꢀnode)ꢀorꢀempty,ꢀflipꢀitꢀupsideꢀdownꢀandꢀturn

itꢀintoꢀaꢀtreeꢀwhereꢀtheꢀoriginalꢀrightꢀnodesꢀturnedꢀintoꢀleftꢀleafꢀnodes.ꢀReturnꢀthe

newꢀroot.

Forꢀexample:ꢀGivenꢀaꢀbinaryꢀtreeꢀ{1,2,3,4,5},ꢀ1ꢀ/ꢀ\ꢀ2ꢀ3ꢀ/ꢀ\ꢀ4ꢀ5ꢀreturnꢀtheꢀrootꢀofꢀthe

binaryꢀtreeꢀ[4,5,2,#,#,3,1].ꢀ4ꢀ/ꢀ\ꢀ5ꢀ2ꢀ/ꢀ\ꢀ3ꢀ1

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀupsideDownBinaryTree(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀroot

ꢀꢀꢀꢀꢀꢀꢀꢀparentꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀparent\_rightꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀp:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀp.left

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.leftꢀ=ꢀparent\_right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀparent\_rightꢀ=ꢀp.right

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.rightꢀ=ꢀparent

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀparentꢀ=ꢀp

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀleft

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀparent

105





BinaryꢀTreeꢀUpsideꢀDown

106





CountꢀUnivalueꢀSubtrees

CountꢀUnivalueꢀSubtrees

Givenꢀaꢀbinaryꢀtree,ꢀcountꢀtheꢀnumberꢀofꢀuni-valueꢀsubtrees.

AꢀUni-valueꢀsubtreeꢀmeansꢀallꢀnodesꢀofꢀtheꢀsubtreeꢀhaveꢀtheꢀsameꢀvalue.

Forꢀexample:ꢀGivenꢀbinaryꢀtree,ꢀ5ꢀ/ꢀ\ꢀ1ꢀ5ꢀ/ꢀ\ꢀ\ꢀ5ꢀ5ꢀ5ꢀreturnꢀ4.

URL:ꢀhttps://leetcode.com/problems/count-univalue-subtrees/

107





CountꢀUnivalueꢀSubtrees

#ꢀDefinitionꢀforꢀaꢀbinaryꢀtreeꢀnode.

#ꢀclassꢀTreeNode(object):

#ꢀꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.leftꢀ=ꢀNone

#ꢀꢀꢀꢀꢀꢀꢀꢀꢀself.rightꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_countꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀcountUnivalSubtrees(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀroot:ꢀTreeNode

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.count\_univalue\_subtrees(root)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.\_\_count

ꢀꢀꢀꢀdefꢀcount\_univalue\_subtrees(self,ꢀroot):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrootꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀroot.leftꢀ==ꢀNoneꢀandꢀroot.rightꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_countꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀleftꢀ=ꢀself.count\_univalue\_subtrees(root.left)

ꢀꢀꢀꢀꢀꢀꢀꢀrightꢀ=ꢀself.count\_univalue\_subtrees(root.right)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(leftꢀandꢀright)ꢀandꢀ(root.leftꢀ==ꢀNoneꢀorꢀroot.left.

valꢀ==ꢀroot.val)ꢀandꢀ(root.rightꢀ==ꢀNoneꢀorꢀroot.right.valꢀ==ꢀro

ot.val):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_countꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

108





NumberꢀofꢀConnectedꢀComponentsꢀinꢀanꢀUndirectedꢀGraph

NumberꢀofꢀConnectedꢀComponentsꢀinꢀan

UndirectedꢀGraph

Givenꢀnꢀnodesꢀlabeledꢀfromꢀ0ꢀtoꢀnꢀ-ꢀ1ꢀandꢀaꢀlistꢀofꢀundirectedꢀedgesꢀ(eachꢀedgeꢀis

aꢀpairꢀofꢀnodes),ꢀwriteꢀaꢀfunctionꢀtoꢀfindꢀtheꢀnumberꢀofꢀconnectedꢀcomponentsꢀin

anꢀundirectedꢀgraph.

URLꢀ:ꢀhttps://leetcode.com/problems/number-of-connected-components-in-an-

undirected-graph/

importꢀsys

fromꢀqueueꢀimportꢀQueue

classꢀVertex:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.idꢀ=ꢀnode

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacentꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀSetꢀdistanceꢀtoꢀinfinityꢀforꢀallꢀnodes

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀunvisitedꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀcolorꢀwithꢀwhiteꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀ'white'ꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀPredecessor

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀNone

ꢀꢀꢀꢀdefꢀaddNeighbor(self,ꢀneighbor,ꢀweight=0):

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacent[neighbor]ꢀ=ꢀweight

ꢀꢀꢀꢀdefꢀgetConnections(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent.keys()ꢀꢀ

ꢀꢀꢀꢀdefꢀgetVertexID(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.id

ꢀꢀꢀꢀdefꢀgetWeight(self,ꢀneighbor):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent[neighbor]

109





NumberꢀofꢀConnectedꢀComponentsꢀinꢀanꢀUndirectedꢀGraph

ꢀꢀꢀꢀdefꢀsetDistance(self,ꢀdist):

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀdist

ꢀꢀꢀꢀdefꢀgetDistance(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.distance

ꢀꢀꢀꢀdefꢀsetColor(self,ꢀcolor):

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀcolor

ꢀꢀꢀꢀdefꢀgetColor(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.colorꢀꢀꢀꢀ

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀprev):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀprev

ꢀꢀꢀꢀdefꢀsetVisited(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀTrue

ꢀꢀꢀꢀdefꢀ\_\_str\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(self.id)ꢀ+ꢀ'ꢀadjacent:ꢀ'ꢀ+ꢀstr([x.idꢀforꢀxꢀin

ꢀself.adjacent])

classꢀGraph:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionaryꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀ\_\_iter\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀiter(self.vertDictionary.values())

ꢀꢀꢀꢀdefꢀaddVertex(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀself.numVerticesꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀnewVertexꢀ=ꢀVertex(node)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[node]ꢀ=ꢀnewVertex

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnewVertex

ꢀꢀꢀꢀdefꢀgetVertex(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary[n]

110





NumberꢀofꢀConnectedꢀComponentsꢀinꢀanꢀUndirectedꢀGraph

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀdefꢀaddEdge(self,ꢀfrm,ꢀto,ꢀcost=0):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfrmꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(frm)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀtoꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(to)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[frm].addNeighbor(self.vertDictionary

[to],ꢀcost)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[to].addNeighbor(self.vertDictionary[

frm],ꢀcost)

ꢀꢀꢀꢀdefꢀgetVertices(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary.keys()

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀcurrent

ꢀꢀꢀꢀdefꢀgetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.previous

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀcountComponents(self,ꢀn,ꢀedges):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀedges:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ1ꢀandꢀedgesꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀGꢀ=ꢀGraph()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀedges:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀG.addEdge(entries[0],ꢀentries[1],ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀvertexꢀinꢀG:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀvertex.getColor()ꢀ==ꢀ"white":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

111





NumberꢀofꢀConnectedꢀComponentsꢀinꢀanꢀUndirectedꢀGraph

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.bfs(vertex)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcount

ꢀꢀꢀꢀdefꢀbfs(self,ꢀvertex):

ꢀꢀꢀꢀꢀꢀꢀꢀvertex.setColor("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀqꢀ=ꢀQueue()

ꢀꢀꢀꢀꢀꢀꢀꢀq.put(vertex)

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀq.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀq.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀnbrꢀinꢀcurr\_node.getConnections():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnbr.getColor()ꢀ==ꢀ"white":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnbr.setColor("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀq.put(nbr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.setColor("black")

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀnꢀ=ꢀ5

ꢀꢀꢀꢀedges1ꢀ=ꢀ[[0,ꢀ1],ꢀ[1,ꢀ2],ꢀ[3,ꢀ4]]

ꢀꢀꢀꢀedges2ꢀ=ꢀ[[0,ꢀ1],ꢀ[1,ꢀ2],ꢀ[2,ꢀ3],ꢀ[3,ꢀ4]]

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.countComponents(n,ꢀedges1))

ꢀꢀꢀꢀprint(soln.countComponents(n,ꢀedges2))

112





CourseꢀSchedule

CourseꢀSchedule

Thereꢀareꢀaꢀtotalꢀofꢀnꢀcoursesꢀyouꢀhaveꢀtoꢀtake,ꢀlabeledꢀfromꢀ0ꢀtoꢀnꢀ-ꢀ1.

Someꢀcoursesꢀmayꢀhaveꢀprerequisites,ꢀforꢀexampleꢀtoꢀtakeꢀcourseꢀ0ꢀyouꢀhaveꢀto

firstꢀtakeꢀcourseꢀ1,ꢀwhichꢀisꢀexpressedꢀasꢀaꢀpair:ꢀ[0,1]

Givenꢀtheꢀtotalꢀnumberꢀofꢀcoursesꢀandꢀaꢀlistꢀofꢀprerequisiteꢀpairs,ꢀisꢀitꢀpossibleꢀfor

youꢀtoꢀfinishꢀallꢀcourses?

Forꢀexample:

2,ꢀ[[1,0]]ꢀThereꢀareꢀaꢀtotalꢀofꢀ2ꢀcoursesꢀtoꢀtake.ꢀToꢀtakeꢀcourseꢀ1ꢀyouꢀshouldꢀhave

finishedꢀcourseꢀ0.ꢀSoꢀitꢀisꢀpossible.

2,ꢀ[[1,0],[0,1]]ꢀThereꢀareꢀaꢀtotalꢀofꢀ2ꢀcoursesꢀtoꢀtake.ꢀToꢀtakeꢀcourseꢀ1ꢀyouꢀshould

haveꢀfinishedꢀcourseꢀ0,ꢀandꢀtoꢀtakeꢀcourseꢀ0ꢀyouꢀshouldꢀalsoꢀhaveꢀfinishedꢀcourse

1.ꢀSoꢀitꢀisꢀimpossible.

Note:ꢀTheꢀinputꢀprerequisitesꢀisꢀaꢀgraphꢀrepresentedꢀbyꢀaꢀlistꢀofꢀedges,ꢀnot

adjacencyꢀmatrices.ꢀReadꢀmoreꢀaboutꢀhowꢀaꢀgraphꢀisꢀrepresented.

URL:ꢀhttps://leetcode.com/problems/course-schedule/

classꢀVertex:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀkey):

ꢀꢀꢀꢀꢀꢀꢀꢀself.idꢀ=ꢀkey

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacentꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀself.indegreeꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀself.outdegreeꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀself.predecessorꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀself.visit\_timeꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀself.finish\_timeꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀ"white"

ꢀꢀꢀꢀdefꢀadd\_neighbor(self,ꢀnbr,ꢀweight=0):

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacent[nbr]ꢀ=ꢀweight

113





CourseꢀSchedule

ꢀꢀꢀꢀdefꢀget\_neighbors(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent.keys()

ꢀꢀꢀꢀdefꢀget\_id(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.id

ꢀꢀꢀꢀdefꢀget\_weight(self,ꢀnbr):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent[nbr]

ꢀꢀꢀꢀdefꢀget\_indegree(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.indegree

ꢀꢀꢀꢀdefꢀset\_indegree(self,ꢀindegree):

ꢀꢀꢀꢀꢀꢀꢀꢀself.indegreeꢀ=ꢀindegree

ꢀꢀꢀꢀdefꢀget\_outdegree(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.outdegree

ꢀꢀꢀꢀdefꢀset\_outdegree(self,ꢀoutdegree):

ꢀꢀꢀꢀꢀꢀꢀꢀself.outdegreeꢀ=ꢀoutdegree

ꢀꢀꢀꢀdefꢀget\_predecessor(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.predecessor

ꢀꢀꢀꢀdefꢀset\_predecessor(self,ꢀpred):

ꢀꢀꢀꢀꢀꢀꢀꢀself.predecessorꢀ=ꢀpred

ꢀꢀꢀꢀdefꢀget\_visit\_time(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.visit\_time

ꢀꢀꢀꢀdefꢀset\_visit\_time(self,ꢀvisit\_time):

ꢀꢀꢀꢀꢀꢀꢀꢀself.visit\_timeꢀ=ꢀvisit\_time

ꢀꢀꢀꢀdefꢀget\_finish\_time(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.finish\_time

ꢀꢀꢀꢀdefꢀset\_finish\_time(self,ꢀfinish\_time):

ꢀꢀꢀꢀꢀꢀꢀꢀself.finish\_timeꢀ=ꢀfinish\_time

ꢀꢀꢀꢀdefꢀget\_color(self):

114





CourseꢀSchedule

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.color

ꢀꢀꢀꢀdefꢀset\_color(self,ꢀcolor):

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀcolor

ꢀꢀꢀꢀdefꢀ\_\_str\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(self.id)ꢀ+ꢀ'ꢀconnectedTo:ꢀ'ꢀ+ꢀstr([x.idꢀforꢀx

ꢀinꢀself.adjacent])

classꢀGraph:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertex\_dictꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀself.no\_verticesꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀself.no\_edgesꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀadd\_vertex(self,ꢀvert\_key):

ꢀꢀꢀꢀꢀꢀꢀꢀnew\_vertex\_objꢀ=ꢀVertex(vert\_key)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertex\_dict[vert\_key]ꢀ=ꢀnew\_vertex\_obj

ꢀꢀꢀꢀꢀꢀꢀꢀself.no\_verticesꢀ+=ꢀ1

ꢀꢀꢀꢀdefꢀget\_vertex(self,ꢀvert\_key):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀvert\_keyꢀinꢀself.vertex\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertex\_dict[vert\_key]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀdefꢀadd\_edge(self,ꢀfro,ꢀto,ꢀweight=1):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfroꢀnotꢀinꢀself.vertex\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.add\_vertex(fro)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfrom\_vertexꢀ=ꢀself.get\_vertex(fro)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfrom\_vertexꢀ=ꢀself.vertex\_dict[fro]

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀtoꢀnotꢀinꢀself.vertex\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.add\_vertex(to)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀto\_vertexꢀ=ꢀself.get\_vertex(to)

115





CourseꢀSchedule

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀto\_vertexꢀ=ꢀself.vertex\_dict[to]

ꢀꢀꢀꢀꢀꢀꢀꢀfrom\_vertex.add\_neighbor(to\_vertex,ꢀweight)

ꢀꢀꢀꢀꢀꢀꢀꢀfrom\_vertex.set\_outdegree(from\_vertex.get\_outdegree()ꢀ+ꢀ

\1)

ꢀꢀꢀꢀꢀꢀꢀꢀto\_vertex.set\_indegree(to\_vertex.get\_indegree()ꢀ+ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀself.no\_edgesꢀ+=ꢀ1

ꢀꢀꢀꢀdefꢀget\_edges(self):

ꢀꢀꢀꢀꢀꢀꢀꢀedgesꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀuꢀinꢀself.vertex\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀvꢀinꢀself.vertex\_dict[u].get\_neighbors():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀu\_idꢀ=ꢀu

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#print(v)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀv\_idꢀ=ꢀv.get\_id()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀedges.append((u\_id,ꢀv\_id,ꢀself.vertex\_dict[u].ge

t\_weight(v)))

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀedges

ꢀꢀꢀꢀdefꢀget\_vertices(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertex\_dict

classꢀDFS:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀgraph):

ꢀꢀꢀꢀꢀꢀꢀꢀself.graphꢀ=ꢀgraph

ꢀꢀꢀꢀꢀꢀꢀꢀself.has\_cycleꢀ=ꢀFalse

ꢀꢀꢀꢀdefꢀdfs(self):

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀvertexꢀinꢀself.graph.get\_vertices():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀself.graph.vertex\_dict[vertex].get\_color()ꢀ==ꢀ"wh

ite":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs\_visit(self.graph.vertex\_dict[vertex])

ꢀꢀꢀꢀdefꢀdfs\_visit(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀnode.set\_color("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀvertꢀinꢀnode.get\_neighbors():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀvert.get\_color()ꢀ==ꢀ"gray":

116





CourseꢀSchedule

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.has\_cycleꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀvert.get\_color()ꢀ==ꢀ"white":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀvert.set\_color("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs\_visit(vert)

ꢀꢀꢀꢀꢀꢀꢀꢀnode.set\_color("black")

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀcanFinish(self,ꢀnumCourses,ꢀprerequisites):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnumCourses:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀprerequisites:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀprerequisites:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀgꢀ=ꢀGraph()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀedgeꢀinꢀprerequisites:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀg.add\_edge(edge[0],ꢀedge[1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdfs\_objꢀ=ꢀDFS(g)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdfs\_obj.dfs()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀdfs\_obj.has\_cycleꢀ==ꢀTrue:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsoln1ꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln1.canFinish(2,ꢀ[[1,0]]))

ꢀꢀꢀꢀsoln2ꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln2.canFinish(2,ꢀ[[1,0],[0,1]]))

117





GraphꢀValidꢀTree

GraphꢀValidꢀTree

Givenꢀnꢀnodesꢀlabeledꢀfromꢀ0ꢀtoꢀnꢀ-ꢀ1ꢀandꢀaꢀlistꢀofꢀundirectedꢀedgesꢀ(eachꢀedgeꢀis

aꢀpairꢀofꢀnodes),ꢀwriteꢀaꢀfunctionꢀtoꢀcheckꢀwhetherꢀtheseꢀedgesꢀmakeꢀupꢀaꢀvalid

tree.

Forꢀexample:

Givenꢀnꢀ=ꢀ5ꢀandꢀedgesꢀ=ꢀ[[0,ꢀ1],ꢀ[0,ꢀ2],ꢀ[0,ꢀ3],ꢀ[1,ꢀ4]],ꢀreturnꢀtrue.

Givenꢀnꢀ=ꢀ5ꢀandꢀedgesꢀ=ꢀ[[0,ꢀ1],ꢀ[1,ꢀ2],ꢀ[2,ꢀ3],ꢀ[1,ꢀ3],ꢀ[1,ꢀ4]],ꢀreturnꢀfalse.

Hint:

Givenꢀnꢀ=ꢀ5ꢀandꢀedgesꢀ=ꢀ[[0,ꢀ1],ꢀ[1,ꢀ2],ꢀ[3,ꢀ4]],ꢀwhatꢀshouldꢀyourꢀreturn?ꢀIsꢀthisꢀcase

aꢀvalidꢀtree?ꢀAccordingꢀtoꢀtheꢀdefinitionꢀofꢀtreeꢀonꢀWikipedia:ꢀ“aꢀtreeꢀisꢀan

undirectedꢀgraphꢀinꢀwhichꢀanyꢀtwoꢀverticesꢀareꢀconnectedꢀbyꢀexactlyꢀoneꢀpath.ꢀIn

otherꢀwords,ꢀanyꢀconnectedꢀgraphꢀwithoutꢀsimpleꢀcyclesꢀisꢀaꢀtree.”

URL:ꢀhttps://leetcode.com/problems/graph-valid-tree/

importꢀsys

classꢀVertex:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.idꢀ=ꢀnode

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacentꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀSetꢀdistanceꢀtoꢀinfinityꢀforꢀallꢀnodes

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀunvisitedꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀcolorꢀwithꢀwhiteꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀ'white'ꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀPredecessor

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀNone

ꢀꢀꢀꢀdefꢀaddNeighbor(self,ꢀneighbor,ꢀweight=0):

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacent[neighbor]ꢀ=ꢀweight

ꢀꢀꢀꢀdefꢀgetConnections(self):

118





GraphꢀValidꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent.keys()ꢀꢀ

ꢀꢀꢀꢀdefꢀgetVertexID(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.id

ꢀꢀꢀꢀdefꢀgetWeight(self,ꢀneighbor):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent[neighbor]

ꢀꢀꢀꢀdefꢀsetDistance(self,ꢀdist):

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀdist

ꢀꢀꢀꢀdefꢀgetDistance(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.distance

ꢀꢀꢀꢀdefꢀsetColor(self,ꢀcolor):

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀcolor

ꢀꢀꢀꢀdefꢀgetColor(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.colorꢀꢀꢀꢀ

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀprev):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀprev

ꢀꢀꢀꢀdefꢀsetVisited(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀTrue

ꢀꢀꢀꢀdefꢀ\_\_str\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(self.id)ꢀ+ꢀ'ꢀadjacent:ꢀ'ꢀ+ꢀstr([x.idꢀforꢀxꢀin

ꢀself.adjacent])

classꢀGraph:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionaryꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀ\_\_iter\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀiter(self.vertDictionary.values())

ꢀꢀꢀꢀdefꢀaddVertex(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀself.numVerticesꢀ+ꢀ1

119





GraphꢀValidꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀnewVertexꢀ=ꢀVertex(node)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[node]ꢀ=ꢀnewVertex

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnewVertex

ꢀꢀꢀꢀdefꢀgetVertex(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary[n]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀdefꢀaddEdge(self,ꢀfrm,ꢀto,ꢀcost=0):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfrmꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(frm)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀtoꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(to)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[frm].addNeighbor(self.vertDictionary

[to],ꢀcost)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[to].addNeighbor(self.vertDictionary[

frm],ꢀcost)

ꢀꢀꢀꢀdefꢀgetVertices(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary.keys()

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀcurrent

ꢀꢀꢀꢀdefꢀgetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.previous

classꢀSolution:

ꢀꢀꢀꢀdefꢀvalidTree(self,ꢀn,ꢀedges):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀedges:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ1ꢀandꢀlen(edges)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀself.check\_input(n,ꢀedges)ꢀ==ꢀFalse:

120





GraphꢀValidꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀnꢀ==ꢀ0ꢀandꢀlen(edges)ꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀnꢀ==ꢀ1ꢀandꢀlen(edges)ꢀ>=ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀGꢀ=ꢀGraph()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀedges:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀG.addEdge(entries[0],ꢀentries[1],ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀvertexꢀinꢀG:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀvertex.getColor()ꢀ==ꢀ"white":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresults.append(self.check\_validity(vertex))ꢀ

ꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(results)ꢀ>ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresults[0]

ꢀꢀꢀꢀdefꢀcheck\_input(self,ꢀn,ꢀedges):

ꢀꢀꢀꢀꢀꢀꢀꢀverticesꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀedges:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀvertices.append(entries[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀvertices.append(entries[1])

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(set(vertices))ꢀ!=ꢀn:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀdefꢀcheck\_validity(self,ꢀstart):

ꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀstart.setColor("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀstack.append(start)

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstackꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀnbrꢀinꢀcurr\_node.getConnections():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnbr.getColor()ꢀ==ꢀ"gray":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

121





GraphꢀValidꢀTree

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnbr.getColor()ꢀ==ꢀ"white":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnbr.setColor("gray")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(nbr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_node.setColor("black")

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

122





CourseꢀScheduleꢀ2

CourseꢀScheduleꢀ2

Thereꢀareꢀaꢀtotalꢀofꢀnꢀcoursesꢀyouꢀhaveꢀtoꢀtake,ꢀlabeledꢀfromꢀ0ꢀtoꢀnꢀ-ꢀ1.

Someꢀcoursesꢀmayꢀhaveꢀprerequisites,ꢀforꢀexampleꢀtoꢀtakeꢀcourseꢀ0ꢀyouꢀhaveꢀto

firstꢀtakeꢀcourseꢀ1,ꢀwhichꢀisꢀexpressedꢀasꢀaꢀpair:ꢀ[0,1]

Givenꢀtheꢀtotalꢀnumberꢀofꢀcoursesꢀandꢀaꢀlistꢀofꢀprerequisiteꢀpairs,ꢀreturnꢀthe

orderingꢀofꢀcoursesꢀyouꢀshouldꢀtakeꢀtoꢀfinishꢀallꢀcourses.

Thereꢀmayꢀbeꢀmultipleꢀcorrectꢀorders,ꢀyouꢀjustꢀneedꢀtoꢀreturnꢀoneꢀofꢀthem.ꢀIfꢀitꢀis

impossibleꢀtoꢀfinishꢀallꢀcourses,ꢀreturnꢀanꢀemptyꢀarray.

Forꢀexample:

2,ꢀ[[1,0]]ꢀThereꢀareꢀaꢀtotalꢀofꢀ2ꢀcoursesꢀtoꢀtake.ꢀToꢀtakeꢀcourseꢀ1ꢀyouꢀshouldꢀhave

finishedꢀcourseꢀ0.ꢀSoꢀtheꢀcorrectꢀcourseꢀorderꢀisꢀ[0,1]

4,ꢀ[[1,0],[2,0],[3,1],[3,2]]ꢀThereꢀareꢀaꢀtotalꢀofꢀ4ꢀcoursesꢀtoꢀtake.ꢀToꢀtakeꢀcourseꢀ3

youꢀshouldꢀhaveꢀfinishedꢀbothꢀcoursesꢀ1ꢀandꢀ2.ꢀBothꢀcoursesꢀ1ꢀandꢀ2ꢀshouldꢀbe

takenꢀafterꢀyouꢀfinishedꢀcourseꢀ0.ꢀSoꢀoneꢀcorrectꢀcourseꢀorderꢀisꢀ[0,1,2,3].ꢀAnother

correctꢀorderingꢀisꢀ[0,2,1,3].

URL:ꢀhttps://leetcode.com/problems/course-schedule-ii/

fromꢀqueueꢀimportꢀQueue

importꢀsys

classꢀVertex:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.idꢀ=ꢀnode

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacentꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀSetꢀdistanceꢀtoꢀinfinityꢀforꢀallꢀnodes

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀunvisitedꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀMarkꢀallꢀnodesꢀcolorꢀwithꢀwhiteꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀ'white'ꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀ#ꢀPredecessor

123





CourseꢀScheduleꢀ2

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀ#indegreeꢀofꢀtheꢀvertex

ꢀꢀꢀꢀꢀꢀꢀꢀself.indegreeꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀaddNeighbor(self,ꢀneighbor,ꢀweight=0):

ꢀꢀꢀꢀꢀꢀꢀꢀself.adjacent[neighbor]ꢀ=ꢀweight

ꢀꢀꢀꢀdefꢀgetConnections(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent.keys()ꢀꢀ

ꢀꢀꢀꢀdefꢀgetVertexID(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.id

ꢀꢀꢀꢀdefꢀgetWeight(self,ꢀneighbor):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.adjacent[neighbor]

ꢀꢀꢀꢀdefꢀsetDistance(self,ꢀdist):

ꢀꢀꢀꢀꢀꢀꢀꢀself.distanceꢀ=ꢀdist

ꢀꢀꢀꢀdefꢀgetDistance(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.distance

ꢀꢀꢀꢀdefꢀsetColor(self,ꢀcolor):

ꢀꢀꢀꢀꢀꢀꢀꢀself.colorꢀ=ꢀcolor

ꢀꢀꢀꢀdefꢀgetColor(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.colorꢀꢀꢀꢀ

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀprev):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀprev

ꢀꢀꢀꢀdefꢀsetVisited(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.visitedꢀ=ꢀTrue

ꢀꢀꢀꢀdefꢀsetIndegree(self,ꢀindegree):

ꢀꢀꢀꢀꢀꢀꢀꢀself.indegreeꢀ=ꢀindegree

ꢀꢀꢀꢀdefꢀgetIndegree(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.indegree

124





CourseꢀScheduleꢀ2

ꢀꢀꢀꢀdefꢀ\_\_str\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(self.id)ꢀ+ꢀ'ꢀadjacent:ꢀ'ꢀ+ꢀstr([x.idꢀforꢀxꢀin

ꢀself.adjacent])

classꢀDirectedGraph:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionaryꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀ0

ꢀꢀꢀꢀdefꢀ\_\_iter\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀiter(self.vertDictionary.values())

ꢀꢀꢀꢀdefꢀaddVertex(self,ꢀnode):

ꢀꢀꢀꢀꢀꢀꢀꢀself.numVerticesꢀ=ꢀself.numVerticesꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀnewVertexꢀ=ꢀVertex(node)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[node]ꢀ=ꢀnewVertex

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnewVertex

ꢀꢀꢀꢀdefꢀgetVertex(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary[n]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀdefꢀaddEdge(self,ꢀfrm,ꢀto,ꢀcost=0):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfrmꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(frm)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀtoꢀnotꢀinꢀself.vertDictionary:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.addVertex(to)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[frm].addNeighbor(self.vertDictionary

[to],ꢀcost)

ꢀꢀꢀꢀꢀꢀꢀꢀself.vertDictionary[to].setIndegree(self.vertDictionary[

to].getIndegree()ꢀ+ꢀ1)

ꢀꢀꢀꢀdefꢀgetVertices(self):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.vertDictionary.keys()

ꢀꢀꢀꢀdefꢀsetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀself.previousꢀ=ꢀcurrent

125





CourseꢀScheduleꢀ2

ꢀꢀꢀꢀdefꢀgetPrevious(self,ꢀcurrent):

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.previous

classꢀSolution:

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.has\_cycleꢀ=ꢀFalse

ꢀꢀꢀꢀdefꢀfindOrder(self,ꢀnumCourses,ꢀprerequisites):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnumCourses:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀprerequisites:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀprerequisitesꢀ==ꢀ[]ꢀandꢀnumCoursesꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[entriesꢀforꢀentriesꢀinꢀrange(numCourses)]

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀprerequisitesꢀ==ꢀ[]ꢀandꢀnumCoursesꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀGꢀ=ꢀDirectedGraph()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀprerequisites:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀG.addEdge(entries[1],ꢀentries[0],ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.topsort(G)

ꢀꢀꢀꢀdefꢀtopsort(self,ꢀG):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀG.getVertices()ꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopological\_listꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopological\_queueꢀ=ꢀQueue()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnodesꢀ=ꢀG.getVertices()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀnodeꢀinꢀG:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnode.getIndegree()ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopological\_queue.put(node)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀtopological\_queue.empty()ꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_nodeꢀ=ꢀtopological\_queue.get()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopological\_list.append(curr\_node.getVertexID())

126





CourseꢀScheduleꢀ2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀnbrꢀinꢀcurr\_node.getConnections():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnbr.setIndegree(nbr.getIndegree()ꢀ-ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnbr.getIndegree()ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopological\_queue.put(nbr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(topological\_list)ꢀ!=ꢀlen(nodes):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.has\_cycleꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀtopological\_list

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.findOrder(4,ꢀ[[1,0],[2,0],[3,1],[3,2]]))

ꢀꢀꢀꢀprint(soln.findOrder(2,ꢀ[[1,0]]))

ꢀꢀꢀꢀprint(soln.findOrder(3,ꢀ[[1,0]]))

127





NumberꢀofꢀIslands

NumberꢀofꢀIslands

Givenꢀaꢀ2dꢀgridꢀmapꢀofꢀ'1'sꢀ(land)ꢀandꢀ'0'sꢀ(water),ꢀcountꢀtheꢀnumberꢀofꢀislands.ꢀAn

islandꢀisꢀsurroundedꢀbyꢀwaterꢀandꢀisꢀformedꢀbyꢀconnectingꢀadjacentꢀlands

horizontallyꢀorꢀvertically.ꢀYouꢀmayꢀassumeꢀallꢀfourꢀedgesꢀofꢀtheꢀgridꢀareꢀall

surroundedꢀbyꢀwater.

Exampleꢀ1:

11110ꢀ11010ꢀ11000ꢀ00000ꢀAnswer:ꢀ1

Exampleꢀ2:

11000ꢀ11000ꢀ00100ꢀ00011ꢀAnswer:ꢀ3

URL:ꢀhttps://leetcode.com/problems/number-of-islands/

128





NumberꢀofꢀIslands

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{boolean[][]}ꢀgridꢀaꢀbooleanꢀ2Dꢀmatrix

ꢀꢀꢀꢀ#ꢀ@returnꢀ{int}ꢀanꢀinteger

ꢀꢀꢀꢀdefꢀnumIslands(self,ꢀgrid):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀgrid:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀrowꢀ=ꢀlen(grid)

ꢀꢀꢀꢀꢀꢀꢀꢀcolꢀ=ꢀlen(grid[0])

ꢀꢀꢀꢀꢀꢀꢀꢀusedꢀ=ꢀ[[Falseꢀforꢀjꢀinꢀxrange(col)]ꢀforꢀiꢀinꢀxrange(row

)]

ꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀxrange(row):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀxrange(col):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀgrid[i][j]ꢀ==ꢀ'1'ꢀandꢀnotꢀused[i][j]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs(grid,ꢀused,ꢀrow,ꢀcol,ꢀi,ꢀj)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcount

ꢀꢀꢀꢀdefꢀdfs(self,ꢀgrid,ꢀused,ꢀrow,ꢀcol,ꢀx,ꢀy):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀgrid[x][y]ꢀ==ꢀ'0'ꢀorꢀused[x][y]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturn

ꢀꢀꢀꢀꢀꢀꢀꢀused[x][y]ꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀxꢀ!=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs(grid,ꢀused,ꢀrow,ꢀcol,ꢀxꢀ-ꢀ1,ꢀy)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀxꢀ!=ꢀrowꢀ-ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs(grid,ꢀused,ꢀrow,ꢀcol,ꢀxꢀ+ꢀ1,ꢀy)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀyꢀ!=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs(grid,ꢀused,ꢀrow,ꢀcol,ꢀx,ꢀyꢀ-ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀyꢀ!=ꢀcolꢀ-ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.dfs(grid,ꢀused,ꢀrow,ꢀcol,ꢀx,ꢀyꢀ+ꢀ1)

129





MergeꢀKꢀSortedꢀLinkedꢀLists

MergeꢀKꢀSortedꢀLinkedꢀLists

Mergeꢀkꢀsortedꢀlinkedꢀlistsꢀandꢀreturnꢀitꢀasꢀoneꢀsortedꢀlist.ꢀAnalyzeꢀandꢀdescribeꢀits

complexity.

URL:ꢀhttps://leetcode.com/problems/merge-k-sorted-lists/

130





MergeꢀKꢀSortedꢀLinkedꢀLists

importꢀheapq

#ꢀDefinitionꢀforꢀsingly-linkedꢀlist.

classꢀListNode(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀx):

ꢀꢀꢀꢀꢀꢀꢀꢀself.valꢀ=ꢀx

ꢀꢀꢀꢀꢀꢀꢀꢀself.nextꢀ=ꢀNone

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmergeKLists(self,ꢀlists):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀlists:ꢀList[ListNode]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀListNode

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlistsꢀ==ꢀ[]ꢀorꢀlistsꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpqꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(lists)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlists[i]ꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀitemꢀ=ꢀ(lists[i].val,ꢀi,ꢀlists[i])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheapq.heappush(pq,ꢀitem)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdummyꢀ=ꢀListNode(0)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀdummy

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀpqꢀ!=ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheap\_itemꢀ=ꢀheapq.heappop(pq)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀp.nextꢀ=ꢀheap\_item[2]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀp.next

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀheap\_item[2].nextꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀitemꢀ=ꢀ(heap\_item[2].next.val,ꢀheap\_item[1],

ꢀheap\_item[2].next)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheapq.heappush(pq,ꢀitem)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdummy.next

131





KthꢀLargestꢀElementꢀinꢀanꢀArray

KthꢀLargestꢀElementꢀinꢀanꢀArray

Findꢀtheꢀkthꢀlargestꢀelementꢀinꢀanꢀunsortedꢀarray.ꢀNoteꢀthatꢀitꢀisꢀtheꢀkthꢀlargest

elementꢀinꢀtheꢀsortedꢀorder,ꢀnotꢀtheꢀkthꢀdistinctꢀelement.

Forꢀexample,ꢀGivenꢀ[3,2,1,5,6,4]ꢀandꢀkꢀ=ꢀ2,ꢀreturnꢀ5.

Note:ꢀYouꢀmayꢀassumeꢀkꢀisꢀalwaysꢀvalid,ꢀ1ꢀ≤ꢀkꢀ≤ꢀarray'sꢀlength

URL:ꢀhttps://leetcode.com/problems/kth-largest-element-in-an-array/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀfindKthLargest(self,ꢀnums,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnumsꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnums

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheapꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheapq.heappush(heap,ꢀ(nums[i],ꢀi))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(k,ꢀlen(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀroot\_elementꢀ=ꢀ[entriesꢀforꢀentriesꢀinꢀheapq.nsm

allest(1,ꢀheap)][0]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindex\_root\_elementꢀ=ꢀheap.index(root\_element)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[j]ꢀ>ꢀroot\_element[0]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheap[index\_root\_element]ꢀ=ꢀ(nums[j],ꢀj)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀheapq.heapify(heap)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀheapq.heappop(heap)[0]

132





2ꢀSumꢀII

2ꢀSumꢀII

Givenꢀanꢀarrayꢀofꢀintegersꢀthatꢀisꢀalreadyꢀsortedꢀinꢀascendingꢀorder,ꢀfindꢀtwo

numbersꢀsuchꢀthatꢀtheyꢀaddꢀupꢀtoꢀaꢀspecificꢀtargetꢀnumber.

TheꢀfunctionꢀtwoSumꢀshouldꢀreturnꢀindicesꢀofꢀtheꢀtwoꢀnumbersꢀsuchꢀthatꢀtheyꢀadd

upꢀtoꢀtheꢀtarget,ꢀwhereꢀindex1ꢀmustꢀbeꢀlessꢀthanꢀindex2.ꢀPleaseꢀnoteꢀthatꢀyour

returnedꢀanswersꢀ(bothꢀindex1ꢀandꢀindex2)ꢀareꢀnotꢀzero-based.

Youꢀmayꢀassumeꢀthatꢀeachꢀinputꢀwouldꢀhaveꢀexactlyꢀoneꢀsolution.

Input:ꢀnumbers={2,ꢀ7,ꢀ11,ꢀ15},ꢀtarget=9ꢀOutput:ꢀindex1=1,ꢀindex2=2

URL:ꢀhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀtwoSum(self,ꢀnumbers,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnumbers:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(numbers)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[-1]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(numbers)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀnumbers[start]ꢀ+ꢀnumbers[end]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ==ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[start+1,ꢀend+1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ<ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ>ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[-1]

133





2ꢀSumꢀII

134





2ꢀSumꢀIII

2ꢀSumꢀIII

DesignꢀandꢀimplementꢀaꢀTwoSumꢀclass.ꢀItꢀshouldꢀsupportꢀtheꢀfollowing

operations:ꢀaddꢀandꢀfind.

addꢀ-ꢀAddꢀtheꢀnumberꢀtoꢀanꢀinternalꢀdataꢀstructure.ꢀfindꢀ-ꢀFindꢀifꢀthereꢀexistsꢀany

pairꢀofꢀnumbersꢀwhichꢀsumꢀisꢀequalꢀtoꢀtheꢀvalue.

Forꢀexample,ꢀadd(1);ꢀadd(3);ꢀadd(5);ꢀfind(4)ꢀ->ꢀtrueꢀfind(7)ꢀ->ꢀfalse

URL:ꢀhttps://leetcode.com/problems/two-sum-iii-data-structure-design/

importꢀcollections

classꢀTwoSum(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀinitializeꢀyourꢀdataꢀstructureꢀhere

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_num\_listꢀ=ꢀcollections.defaultdict(int)

ꢀꢀꢀꢀdefꢀadd(self,ꢀnumber):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀAddꢀtheꢀnumberꢀtoꢀanꢀinternalꢀdataꢀstructure.

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀnothing

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_num\_list[number]ꢀ+=ꢀ1

ꢀꢀꢀꢀdefꢀfind(self,ꢀvalue):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀFindꢀifꢀthereꢀexistsꢀanyꢀpairꢀofꢀnumbersꢀwhichꢀsumꢀisꢀeq

ualꢀtoꢀtheꢀvalue.

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀvalue:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

135





2ꢀSumꢀIII

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(self.\_\_num\_list)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀself.\_\_num\_list.keys():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtargetꢀ=ꢀvalueꢀ-ꢀentries

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(targetꢀinꢀself.\_\_num\_list)ꢀandꢀ(entriesꢀ!=ꢀt

argetꢀorꢀself.\_\_num\_list[target]ꢀ>ꢀ1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀ#ꢀYourꢀTwoSumꢀobjectꢀwillꢀbeꢀinstantiatedꢀandꢀcalledꢀasꢀsuch

:

ꢀꢀꢀꢀtwoSumꢀ=ꢀTwoSum()

ꢀꢀꢀꢀtwoSum.add(0)

ꢀꢀꢀꢀtwoSum.add(0)

ꢀꢀꢀꢀprint(twoSum.find(0))

136





ContainsꢀDuplicate

ContainsꢀDuplicate

Givenꢀanꢀarrayꢀofꢀintegers,ꢀfindꢀifꢀtheꢀarrayꢀcontainsꢀanyꢀduplicates.ꢀYourꢀfunction

shouldꢀreturnꢀtrueꢀifꢀanyꢀvalueꢀappearsꢀatꢀleastꢀtwiceꢀinꢀtheꢀarray,ꢀandꢀitꢀshould

returnꢀfalseꢀifꢀeveryꢀelementꢀisꢀdistinct.

URL:ꢀhttps://leetcode.com/problems/contains-duplicate/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀcontainsDuplicate(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdup\_dictꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀentriesꢀinꢀdup\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdup\_dict[entries]ꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

137





RotateꢀArray

RotateꢀArray

Rotateꢀanꢀarrayꢀofꢀnꢀelementsꢀtoꢀtheꢀrightꢀbyꢀkꢀsteps.

Forꢀexample,ꢀwithꢀnꢀ=ꢀ7ꢀandꢀkꢀ=ꢀ3,ꢀtheꢀarrayꢀ[1,2,3,4,5,6,7]ꢀisꢀrotatedꢀto

[5,6,7,1,2,3,4].

Note:ꢀTryꢀtoꢀcomeꢀupꢀasꢀmanyꢀsolutionsꢀasꢀyouꢀcan,ꢀthereꢀareꢀatꢀleastꢀ3ꢀdifferent

waysꢀtoꢀsolveꢀthisꢀproblem.

URL:ꢀhttps://leetcode.com/problems/rotate-array/

138





RotateꢀArray

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀrotate(self,ꢀnums,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀnumsꢀin-plac

eꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀnꢀ=ꢀlen(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ<ꢀ2ꢀorꢀkꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀkꢀ>=ꢀn:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ=ꢀkꢀ%ꢀn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀaꢀ=ꢀnꢀ-ꢀk

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.reverse(nums,ꢀ0,ꢀa-1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.reverse(nums,ꢀa,ꢀn-1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.reverse(nums,ꢀ0,ꢀn-1)

ꢀꢀꢀꢀdefꢀreverse(self,ꢀnums,ꢀstart,ꢀend):

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀstart

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀend

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀj:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums[i],ꢀnums[j]ꢀ=ꢀnums[j],ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ-=ꢀ1

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀnumsꢀ=ꢀ[1,2,3,4,5,6,7]

ꢀꢀꢀꢀsoln.rotate(nums,ꢀ3)

ꢀꢀꢀꢀprint(nums)

139





3ꢀSumꢀSmaller

3ꢀSumꢀSmaller

Givenꢀanꢀarrayꢀofꢀnꢀintegersꢀnumsꢀandꢀaꢀtarget,ꢀfindꢀtheꢀnumberꢀofꢀindexꢀtripletsꢀi,

j,ꢀkꢀwithꢀ0ꢀ<=ꢀiꢀ<ꢀjꢀ<ꢀkꢀ<ꢀnꢀthatꢀsatisfyꢀtheꢀconditionꢀnums[i]ꢀ+ꢀnums[j]ꢀ+ꢀnums[k]ꢀ<

target.

Forꢀexample,ꢀgivenꢀnumsꢀ=ꢀ[-2,ꢀ0,ꢀ1,ꢀ3],ꢀandꢀtargetꢀ=ꢀ2.

Returnꢀ2.ꢀBecauseꢀthereꢀareꢀtwoꢀtripletsꢀwhichꢀsumsꢀareꢀlessꢀthanꢀ2:

[-2,ꢀ0,ꢀ1]ꢀ[-2,ꢀ0,ꢀ3]

URL:ꢀhttps://leetcode.com/problems/3sum-smaller/

140





3ꢀSumꢀSmaller

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀthreeSumSmaller(self,ꢀnums,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nums)ꢀ==ꢀ0ꢀorꢀlen(nums)ꢀ==ꢀ2ꢀorꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlen([])

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtriplet\_listꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsorted\_numsꢀ=ꢀsorted(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(nums)ꢀ-ꢀ2):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀiꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(nums)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀsorted\_nums[i]ꢀ+ꢀsorted\_nums[star

t]ꢀ+ꢀsorted\_nums[end]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ==ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ<ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtripletꢀ=ꢀ(sorted\_nums[i],ꢀsorted\_nums[s

tart],ꢀsorted\_nums[end])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtriplet\_list.append(triplet)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ>ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprint(triplet\_list)ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#returnꢀlen([list(entries)ꢀforꢀentriesꢀinꢀset(triple

t\_list)])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlen(triplet\_list)

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.threeSumSmaller([3,1,0,-2],ꢀ4))

141





3ꢀSumꢀClosest

3ꢀSumꢀClosest

GivenꢀanꢀarrayꢀSꢀofꢀnꢀintegers,ꢀfindꢀthreeꢀintegersꢀinꢀSꢀsuchꢀthatꢀtheꢀsumꢀisꢀclosest

toꢀaꢀgivenꢀnumber,ꢀtarget.ꢀReturnꢀtheꢀsumꢀofꢀtheꢀthreeꢀintegers.ꢀYouꢀmayꢀassume

thatꢀeachꢀinputꢀwouldꢀhaveꢀexactlyꢀoneꢀsolution.

Forꢀexample,ꢀgivenꢀarrayꢀSꢀ=ꢀ{-1ꢀ2ꢀ1ꢀ-4},ꢀandꢀtargetꢀ=ꢀ1.

Theꢀsumꢀthatꢀisꢀclosestꢀtoꢀtheꢀtargetꢀisꢀ2.ꢀ(-1ꢀ+ꢀ2ꢀ+ꢀ1ꢀ=ꢀ2).

URL:ꢀhttps://leetcode.com/problems/3sum-closest/

142





3ꢀSumꢀClosest

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀthreeSumClosest(self,ꢀnums,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nums)ꢀinꢀ[0,1,2]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_diffꢀ=ꢀsys.maxsize

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsorted\_numsꢀ=ꢀsorted(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀiꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(nums)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀsorted\_nums[i]ꢀ+ꢀsorted\_nums[star

t]ꢀ+ꢀsorted\_nums[end]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdiffꢀ=ꢀabs(curr\_sumꢀ-ꢀtarget)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀdiffꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcurr\_sum

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀdiffꢀ<ꢀmin\_diff:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_diffꢀ=ꢀdiff

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀcurr\_sum

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ<=ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresult

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.threeSumClosest([-1,ꢀ2,ꢀ1,ꢀ-4],ꢀ1))

ꢀꢀꢀꢀprint(soln.threeSumClosest([-1,ꢀ2,ꢀ1,ꢀ-4],ꢀ3))

143





3ꢀSumꢀClosest

144





3ꢀSum

3ꢀSum

GivenꢀanꢀarrayꢀSꢀofꢀnꢀintegers,ꢀareꢀthereꢀelementsꢀa,ꢀb,ꢀcꢀinꢀSꢀsuchꢀthatꢀaꢀ+ꢀbꢀ+ꢀc

=ꢀ0?ꢀFindꢀallꢀuniqueꢀtripletsꢀinꢀtheꢀarrayꢀwhichꢀgivesꢀtheꢀsumꢀofꢀzero.

Note:ꢀTheꢀsolutionꢀsetꢀmustꢀnotꢀcontainꢀduplicateꢀtriplets.

Forꢀexample,ꢀgivenꢀarrayꢀSꢀ=ꢀ[-1,ꢀ0,ꢀ1,ꢀ2,ꢀ-1,ꢀ-4],

Aꢀsolutionꢀsetꢀis:ꢀ[ꢀ[-1,ꢀ0,ꢀ1],ꢀ[-1,ꢀ-1,ꢀ2]ꢀ]

URL:ꢀhttps://leetcode.com/problems/3sum/

145





3ꢀSum

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀthreeSum(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nums)ꢀ==ꢀ0ꢀorꢀlen(nums)ꢀ==ꢀ2ꢀorꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsum\_zero\_listꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsorted\_numsꢀ=ꢀsorted(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(nums)ꢀ-ꢀ2):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀiꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(nums)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀsorted\_nums[i]ꢀ+ꢀsorted\_nums[star

t]ꢀ+ꢀsorted\_nums[end]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀzero\_tripletꢀ=ꢀ(sorted\_nums[i],ꢀsorted\_n

ums[start],ꢀsorted\_nums[end])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsum\_zero\_list.append(zero\_triplet)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀcurr\_sumꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[list(entries)ꢀforꢀentriesꢀinꢀset(sum\_zero\_li

st)]

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.threeSum([-1,ꢀ0,ꢀ1,ꢀ2,ꢀ-1,ꢀ-4]))

146





TwoꢀSum

TwoꢀSum

Givenꢀanꢀarrayꢀofꢀintegers,ꢀreturnꢀindicesꢀofꢀtheꢀtwoꢀnumbersꢀsuchꢀthatꢀtheyꢀadd

upꢀtoꢀaꢀspecificꢀtarget.

Youꢀmayꢀassumeꢀthatꢀeachꢀinputꢀwouldꢀhaveꢀexactlyꢀoneꢀsolution.

Example:ꢀGivenꢀnumsꢀ=ꢀ[2,ꢀ7,ꢀ11,ꢀ15],ꢀtargetꢀ=ꢀ9,

Becauseꢀnums[0]ꢀ+ꢀnums[1]ꢀ=ꢀ2ꢀ+ꢀ7ꢀ=ꢀ9,ꢀreturnꢀ[0,ꢀ1].

URL:ꢀhttps://leetcode.com/problems/two-sum/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀtwoSum(self,ꢀnums,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀdictꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxꢀ=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀtarget-xꢀinꢀdict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ(dict[target-x],ꢀi)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdict[x]ꢀ=ꢀi

147





PlusꢀOne

PlusꢀOne

Givenꢀaꢀnon-negativeꢀnumberꢀrepresentedꢀasꢀanꢀarrayꢀofꢀdigits,ꢀplusꢀoneꢀtoꢀthe

number.

Theꢀdigitsꢀareꢀstoredꢀsuchꢀthatꢀtheꢀmostꢀsignificantꢀdigitꢀisꢀatꢀtheꢀheadꢀofꢀtheꢀlist.

URL:ꢀhttps://leetcode.com/problems/plus-one/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀplusOne(self,ꢀdigits):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀdigits:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(digits)ꢀ<=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[0]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcarryꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀlen(digits)-1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrunning\_sumꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnew\_digitsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ>=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrunning\_sumꢀ=ꢀdigits[i]ꢀ+ꢀcarry

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀrunning\_sumꢀ>=ꢀ10:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcarryꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcarryꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnew\_digits.append(running\_sumꢀ%ꢀ10)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcarryꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnew\_digits.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnew\_digits[::-1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnew\_digits[::-1]

148





PlusꢀOne

149





BestꢀTimeꢀtoꢀBuyꢀandꢀSellꢀStock

BestꢀTimeꢀtoꢀBuyꢀandꢀSellꢀStock

Sayꢀyouꢀhaveꢀanꢀarrayꢀforꢀwhichꢀtheꢀithꢀelementꢀisꢀtheꢀpriceꢀofꢀaꢀgivenꢀstockꢀon

dayꢀi.

Ifꢀyouꢀwereꢀonlyꢀpermittedꢀtoꢀcompleteꢀatꢀmostꢀoneꢀtransactionꢀ(ie,ꢀbuyꢀoneꢀand

sellꢀoneꢀshareꢀofꢀtheꢀstock),ꢀdesignꢀanꢀalgorithmꢀtoꢀfindꢀtheꢀmaximumꢀprofit.

Exampleꢀ1:ꢀInput:ꢀ[7,ꢀ1,ꢀ5,ꢀ3,ꢀ6,ꢀ4]ꢀOutput:ꢀ5

max.ꢀdifferenceꢀ=ꢀ6-1ꢀ=ꢀ5ꢀ(notꢀ7-1ꢀ=ꢀ6,ꢀasꢀsellingꢀpriceꢀneedsꢀtoꢀbeꢀlargerꢀthan

buyingꢀprice)ꢀExampleꢀ2:ꢀInput:ꢀ[7,ꢀ6,ꢀ4,ꢀ3,ꢀ1]ꢀOutput:ꢀ0

Inꢀthisꢀcase,ꢀnoꢀtransactionꢀisꢀdone,ꢀi.e.ꢀmaxꢀprofitꢀ=ꢀ0.

URL:ꢀhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmaxProfit(self,ꢀprices):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀprices:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(prices)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_profitꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_priceꢀ=ꢀprices[0]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(prices)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprofitꢀ=ꢀprices[i]ꢀ-ꢀmin\_price

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_profitꢀ=ꢀmax(profit,ꢀmax\_profit)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_priceꢀ=ꢀmin(min\_price,ꢀprices[i])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax\_profit

150





ShortestꢀWordꢀDistance

ShortestꢀWordꢀDistance

Givenꢀaꢀlistꢀofꢀwordsꢀandꢀtwoꢀwordsꢀword1ꢀandꢀword2,ꢀreturnꢀtheꢀshortestꢀdistance

betweenꢀtheseꢀtwoꢀwordsꢀinꢀtheꢀlist.

Forꢀexample,ꢀAssumeꢀthatꢀwordsꢀ=ꢀ["practice",ꢀ"makes",ꢀ"perfect",ꢀ"coding",

"makes"].

Givenꢀword1ꢀ=ꢀ“coding”,ꢀword2ꢀ=ꢀ“practice”,ꢀreturnꢀ3.ꢀGivenꢀword1ꢀ=ꢀ"makes",

word2ꢀ=ꢀ"coding",ꢀreturnꢀ1.

Note:ꢀYouꢀmayꢀassumeꢀthatꢀword1ꢀdoesꢀnotꢀequalꢀtoꢀword2,ꢀandꢀword1ꢀandꢀword2

areꢀbothꢀinꢀtheꢀlist.

URL:ꢀhttps://leetcode.com/problems/shortest-word-distance/

151





ShortestꢀWordꢀDistance

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀshortestDistance(self,ꢀwords,ꢀword1,ꢀword2):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀwords:ꢀList[str]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀword1:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀword2:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀword2\_positionsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀword1\_positionsꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(words)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀword1ꢀ==ꢀwords[i]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀword1\_positions.append(i)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀword2ꢀ==ꢀwords[i]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀword2\_positions.append(i)

ꢀꢀꢀꢀꢀꢀꢀꢀmin\_distꢀ=ꢀsys.maxint

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀpos1ꢀinꢀword1\_positions:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀpos2ꢀinꢀword2\_positions:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀabs(pos1ꢀ-ꢀpos2)ꢀ<ꢀmin\_dist:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmin\_distꢀ=ꢀabs(pos1ꢀ-ꢀpos2)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmin\_dist

152





MoveꢀZeroes

MoveꢀZeroes

Givenꢀanꢀarrayꢀnums,ꢀwriteꢀaꢀfunctionꢀtoꢀmoveꢀallꢀ0'sꢀtoꢀtheꢀendꢀofꢀitꢀwhile

maintainingꢀtheꢀrelativeꢀorderꢀofꢀtheꢀnon-zeroꢀelements.

Forꢀexample,ꢀgivenꢀnumsꢀ=ꢀ[0,ꢀ1,ꢀ0,ꢀ3,ꢀ12],ꢀafterꢀcallingꢀyourꢀfunction,ꢀnumsꢀshould

beꢀ[1,ꢀ3,ꢀ12,ꢀ0,ꢀ0].

Note:ꢀYouꢀmustꢀdoꢀthisꢀin-placeꢀwithoutꢀmakingꢀaꢀcopyꢀofꢀtheꢀarray.ꢀMinimizeꢀthe

totalꢀnumberꢀofꢀoperations.

URL:https://leetcode.com/problems/move-zeroes/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmoveZeroes(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀnumsꢀin-plac

eꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀjꢀ<ꢀlen(nums):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[j]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums[i]ꢀ=ꢀnums[j]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀlen(nums):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums[i]ꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

153





ContainsꢀDuplicateꢀII

ContainsꢀDuplicateꢀII

Givenꢀanꢀarrayꢀofꢀintegersꢀandꢀanꢀintegerꢀk,ꢀfindꢀoutꢀwhetherꢀthereꢀareꢀtwoꢀdistinct

indicesꢀiꢀandꢀjꢀinꢀtheꢀarrayꢀsuchꢀthatꢀnums[i]ꢀ=ꢀnums[j]ꢀandꢀtheꢀdifferenceꢀbetweenꢀi

andꢀjꢀisꢀatꢀmostꢀk.

URL:ꢀhttps://leetcode.com/problems/contains-duplicate-ii/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀcontainsNearbyDuplicate(self,ꢀnums,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[0]ꢀ!=ꢀnums[1]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[0]ꢀ==ꢀnums[1]ꢀandꢀkꢀ>=ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindex\_dictꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[i]ꢀinꢀindex\_dict:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprev\_indexꢀ=ꢀindex\_dict[nums[i]]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀiꢀ-ꢀprev\_indexꢀ<=ꢀk:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindex\_dict[nums[i]]ꢀ=ꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

154





ContainsꢀDuplicateꢀII

155





MajorityꢀElement

MajorityꢀElement

Givenꢀanꢀarrayꢀofꢀsizeꢀn,ꢀfindꢀtheꢀmajorityꢀelement.ꢀTheꢀmajorityꢀelementꢀisꢀthe

elementꢀthatꢀappearsꢀmoreꢀthanꢀ⌊ꢀn/2ꢀ⌋ꢀtimes.

Youꢀmayꢀassumeꢀthatꢀtheꢀarrayꢀisꢀnon-emptyꢀandꢀtheꢀmajorityꢀelementꢀalways

existꢀinꢀtheꢀarray.

URL:ꢀhttps://leetcode.com/problems/majority-element/

156





MajorityꢀElement

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmajorityElement(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀcandidateꢀ=ꢀself.get\_candidate(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀcandidate\_countꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀcandidateꢀ!=ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀentriesꢀ==ꢀcandidate:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcandidate\_countꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcandidate\_countꢀ>=ꢀlen(nums)//2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcandidate

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀdefꢀget\_candidate(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀcandidateꢀ=ꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcountꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcandidateꢀ=ꢀentries

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcandidateꢀ==ꢀentries:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀcountꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀcandidate

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

157





MajorityꢀElement

158





RemoveꢀDuplicatesꢀfromꢀSortedꢀArray

RemoveꢀDuplicatesꢀfromꢀSortedꢀArray

Givenꢀaꢀsortedꢀarray,ꢀremoveꢀtheꢀduplicatesꢀinꢀplaceꢀsuchꢀthatꢀeachꢀelement

appearꢀonlyꢀonceꢀandꢀreturnꢀtheꢀnewꢀlength.

Doꢀnotꢀallocateꢀextraꢀspaceꢀforꢀanotherꢀarray,ꢀyouꢀmustꢀdoꢀthisꢀinꢀplaceꢀwith

constantꢀmemory.

Forꢀexample,ꢀGivenꢀinputꢀarrayꢀnumsꢀ=ꢀ[1,1,2],

Yourꢀfunctionꢀshouldꢀreturnꢀlengthꢀ=ꢀ2,ꢀwithꢀtheꢀfirstꢀtwoꢀelementsꢀofꢀnumsꢀbeingꢀ1

andꢀ2ꢀrespectively.ꢀItꢀdoesn'tꢀmatterꢀwhatꢀyouꢀleaveꢀbeyondꢀtheꢀnewꢀlength.

URL:ꢀhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀremoveDuplicates(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nums)ꢀ<ꢀ2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlen(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀlen(nums):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[j]ꢀ==ꢀnums[i]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums[j]ꢀ=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀj+1

159





NestedꢀListꢀWeightꢀSum

NestedꢀListꢀWeightꢀSum

Givenꢀaꢀnestedꢀlistꢀofꢀintegers,ꢀreturnꢀtheꢀsumꢀofꢀallꢀintegersꢀinꢀtheꢀlistꢀweightedꢀby

theirꢀdepth.

Eachꢀelementꢀisꢀeitherꢀanꢀinteger,ꢀorꢀaꢀlistꢀ--ꢀwhoseꢀelementsꢀmayꢀalsoꢀbeꢀintegers

orꢀotherꢀlists.

Exampleꢀ1:ꢀGivenꢀtheꢀlistꢀ[[1,1],2,[1,1]],ꢀreturnꢀ10.ꢀ(fourꢀ1'sꢀatꢀdepthꢀ2,ꢀoneꢀ2ꢀat

depthꢀ1)

Exampleꢀ2:ꢀGivenꢀtheꢀlistꢀ[1,[4,[6]]],ꢀreturnꢀ27.ꢀ(oneꢀ1ꢀatꢀdepthꢀ1,ꢀoneꢀ4ꢀatꢀdepthꢀ2,

andꢀoneꢀ6ꢀatꢀdepthꢀ3;ꢀ1ꢀ+ꢀ42ꢀ+ꢀ63ꢀ=ꢀ27)

URL:ꢀhttps://leetcode.com/problems/nested-list-weight-sum/

#ꢀ"""

#ꢀThisꢀisꢀtheꢀinterfaceꢀthatꢀallowsꢀforꢀcreatingꢀnestedꢀlists.

#ꢀYouꢀshouldꢀnotꢀimplementꢀit,ꢀorꢀspeculateꢀaboutꢀitsꢀimplementa

tion

#ꢀ"""

#classꢀNestedInteger(object):

#ꢀꢀꢀꢀdefꢀisInteger(self):

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

#ꢀꢀꢀꢀꢀꢀꢀꢀ@returnꢀTrueꢀifꢀthisꢀNestedIntegerꢀholdsꢀaꢀsingleꢀinteg

er,ꢀratherꢀthanꢀaꢀnestedꢀlist.

#ꢀꢀꢀꢀꢀꢀꢀꢀ:rtypeꢀbool

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

\#

#ꢀꢀꢀꢀdefꢀgetInteger(self):

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

#ꢀꢀꢀꢀꢀꢀꢀꢀ@returnꢀtheꢀsingleꢀintegerꢀthatꢀthisꢀNestedIntegerꢀhold

s,ꢀifꢀitꢀholdsꢀaꢀsingleꢀinteger

#ꢀꢀꢀꢀꢀꢀꢀꢀReturnꢀNoneꢀifꢀthisꢀNestedIntegerꢀholdsꢀaꢀnestedꢀlist

#ꢀꢀꢀꢀꢀꢀꢀꢀ:rtypeꢀint

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

\#

#ꢀꢀꢀꢀdefꢀgetList(self):

160





NestedꢀListꢀWeightꢀSum

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

#ꢀꢀꢀꢀꢀꢀꢀꢀ@returnꢀtheꢀnestedꢀlistꢀthatꢀthisꢀNestedIntegerꢀholds,ꢀ

ifꢀitꢀholdsꢀaꢀnestedꢀlist

#ꢀꢀꢀꢀꢀꢀꢀꢀReturnꢀNoneꢀifꢀthisꢀNestedIntegerꢀholdsꢀaꢀsingleꢀintege

r

#ꢀꢀꢀꢀꢀꢀꢀꢀ:rtypeꢀList[NestedInteger]

#ꢀꢀꢀꢀꢀꢀꢀꢀ"""

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀdepthSum(self,ꢀnestedList):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnestedList:ꢀList[NestedInteger]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.depthSum\_helper(nestedList,ꢀ1)

ꢀꢀꢀꢀdefꢀdepthSum\_helper(self,ꢀnested\_list,ꢀdepth):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nested\_list)ꢀ==ꢀ0ꢀorꢀnested\_listꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsumꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnested\_list:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀentries.isInteger():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsumꢀ+=ꢀentries.getInteger()\*depth

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsumꢀ+=ꢀself.depthSum\_helper(entries.getList(

),ꢀdepthꢀ+ꢀ1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀsum

161





NestedꢀListꢀWeightedꢀSumꢀII

NestedꢀListꢀWeightedꢀSumꢀII

Givenꢀaꢀnestedꢀlistꢀofꢀintegers,ꢀreturnꢀtheꢀsumꢀofꢀallꢀintegersꢀinꢀtheꢀlistꢀweightedꢀby

theirꢀdepth.

Eachꢀelementꢀisꢀeitherꢀanꢀinteger,ꢀorꢀaꢀlistꢀ--ꢀwhoseꢀelementsꢀmayꢀalsoꢀbeꢀintegers

orꢀotherꢀlists.

Differentꢀfromꢀtheꢀpreviousꢀquestionꢀwhereꢀweightꢀisꢀincreasingꢀfromꢀrootꢀtoꢀleaf,

nowꢀtheꢀweightꢀisꢀdefinedꢀfromꢀbottomꢀup.ꢀi.e.,ꢀtheꢀleafꢀlevelꢀintegersꢀhaveꢀweight

1,ꢀandꢀtheꢀrootꢀlevelꢀintegersꢀhaveꢀtheꢀlargestꢀweight.

Exampleꢀ1:ꢀGivenꢀtheꢀlistꢀ[[1,1],2,[1,1]],ꢀreturnꢀ8.ꢀ(fourꢀ1'sꢀatꢀdepthꢀ1,ꢀoneꢀ2ꢀat

depthꢀ2)

Exampleꢀ2:ꢀGivenꢀtheꢀlistꢀ[1,[4,[6]]],ꢀreturnꢀ17.ꢀ(oneꢀ1ꢀatꢀdepthꢀ3,ꢀoneꢀ4ꢀatꢀdepthꢀ2,

andꢀoneꢀ6ꢀatꢀdepthꢀ1;ꢀ13ꢀ+ꢀ42ꢀ+ꢀ6\*1ꢀ=ꢀ17)

URL:ꢀhttps://leetcode.com/problems/nested-list-weight-sum-ii/

162





RemoveꢀElement

RemoveꢀElement

Givenꢀanꢀarrayꢀandꢀaꢀvalue,ꢀremoveꢀallꢀinstancesꢀofꢀthatꢀvalueꢀinꢀplaceꢀandꢀreturn

theꢀnewꢀlength.

Doꢀnotꢀallocateꢀextraꢀspaceꢀforꢀanotherꢀarray,ꢀyouꢀmustꢀdoꢀthisꢀinꢀplaceꢀwith

constantꢀmemory.

Theꢀorderꢀofꢀelementsꢀcanꢀbeꢀchanged.ꢀItꢀdoesn'tꢀmatterꢀwhatꢀyouꢀleaveꢀbeyond

theꢀnewꢀlength.

Example:ꢀGivenꢀinputꢀarrayꢀnumsꢀ=ꢀ[3,2,2,3],ꢀvalꢀ=ꢀ3

Yourꢀfunctionꢀshouldꢀreturnꢀlengthꢀ=ꢀ2,ꢀwithꢀtheꢀfirstꢀtwoꢀelementsꢀofꢀnumsꢀbeingꢀ2.

URL:ꢀhttps://leetcode.com/problems/remove-element/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀremoveElement(self,ꢀnums,ꢀval):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀval:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀvalꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀjꢀ<ꢀlen(nums):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[j]ꢀ==ꢀval:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums[i]ꢀ=ꢀnums[j]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀlen(nums[0:i])

163





RemoveꢀElement

164





IntersectionꢀofꢀTwoꢀArraysꢀII

IntersectionꢀofꢀTwoꢀArraysꢀII

Givenꢀtwoꢀarrays,ꢀwriteꢀaꢀfunctionꢀtoꢀcomputeꢀtheirꢀintersection.

Example:ꢀGivenꢀnums1ꢀ=ꢀ[1,ꢀ2,ꢀ2,ꢀ1],ꢀnums2ꢀ=ꢀ[2,ꢀ2],ꢀreturnꢀ[2,ꢀ2].

Note:ꢀEachꢀelementꢀinꢀtheꢀresultꢀshouldꢀappearꢀasꢀmanyꢀtimesꢀasꢀitꢀshowsꢀinꢀboth

arrays.ꢀTheꢀresultꢀcanꢀbeꢀinꢀanyꢀorder.ꢀFollowꢀup:ꢀWhatꢀifꢀtheꢀgivenꢀarrayꢀis

alreadyꢀsorted?ꢀHowꢀwouldꢀyouꢀoptimizeꢀyourꢀalgorithm?ꢀWhatꢀifꢀnums1'sꢀsizeꢀis

smallꢀcomparedꢀtoꢀnums2'sꢀsize?ꢀWhichꢀalgorithmꢀisꢀbetter?ꢀWhatꢀifꢀelementsꢀof

nums2ꢀareꢀstoredꢀonꢀdisk,ꢀandꢀtheꢀmemoryꢀisꢀlimitedꢀsuchꢀthatꢀyouꢀcannotꢀloadꢀall

elementsꢀintoꢀtheꢀmemoryꢀatꢀonce?

URL:ꢀhttps://leetcode.com/problems/intersection-of-two-arrays-ii/

165





IntersectionꢀofꢀTwoꢀArraysꢀII

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀintersect(self,ꢀnums1,ꢀnums2):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums1:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums2:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀsorted\_nums1ꢀ=ꢀsorted(nums1)

ꢀꢀꢀꢀꢀꢀꢀꢀsorted\_nums2ꢀ=ꢀsorted(nums2)

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀintersect\_listꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀlen(sorted\_nums1)ꢀandꢀjꢀ<ꢀlen(sorted\_nums2):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀsorted\_nums1[i]ꢀ<ꢀsorted\_nums2[j]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀsorted\_nums2[j]ꢀ<ꢀsorted\_nums1[i]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀintersect\_list.append(sorted\_nums1[i])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀintersect\_list

166





MergeꢀSortedꢀArrays

MergeꢀSortedꢀArrays

Givenꢀtwoꢀsortedꢀintegerꢀarraysꢀnums1ꢀandꢀnums2,ꢀmergeꢀnums2ꢀintoꢀnums1ꢀas

oneꢀsortedꢀarray.

Note:ꢀYouꢀmayꢀassumeꢀthatꢀnums1ꢀhasꢀenoughꢀspaceꢀ(sizeꢀthatꢀisꢀgreaterꢀor

equalꢀtoꢀmꢀ+ꢀn)ꢀtoꢀholdꢀadditionalꢀelementsꢀfromꢀnums2.ꢀTheꢀnumberꢀofꢀelements

initializedꢀinꢀnums1ꢀandꢀnums2ꢀareꢀmꢀandꢀnꢀrespectively.

URL:ꢀhttps://leetcode.com/problems/merge-sorted-array/

167





MergeꢀSortedꢀArrays

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmerge(self,ꢀnums1,ꢀm,ꢀnums2,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums1:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀm:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums2:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀnums1ꢀin-pla

ceꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀlast1ꢀ=ꢀmꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀlast2ꢀ=ꢀnꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀlastꢀ=ꢀmꢀ+ꢀnꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀlast1ꢀ>=ꢀ0ꢀandꢀlast2ꢀ>=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums1[last1]ꢀ>ꢀnums2[last2]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums1[last]ꢀ=ꢀnums1[last1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlast1ꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlastꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums1[last]ꢀ=ꢀnums2[last2]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlast2ꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlastꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀlast2ꢀ>=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnums1[last]ꢀ=ꢀnums2[last2]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlastꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlast2ꢀ-=ꢀ1

168





ReverseꢀVowelsꢀofꢀaꢀString

ReverseꢀVowelsꢀofꢀaꢀString

Writeꢀaꢀfunctionꢀthatꢀtakesꢀaꢀstringꢀasꢀinputꢀandꢀreverseꢀonlyꢀtheꢀvowelsꢀofꢀa

string.

Exampleꢀ1:ꢀGivenꢀsꢀ=ꢀ"hello",ꢀreturnꢀ"holle".

Exampleꢀ2:ꢀGivenꢀsꢀ=ꢀ"leetcode",ꢀreturnꢀ"leotcede".

Note:ꢀTheꢀvowelsꢀdoesꢀnotꢀincludeꢀtheꢀletterꢀ"y".

URL:ꢀhttps://leetcode.com/problems/reverse-vowels-of-a-string/

169





ReverseꢀVowelsꢀofꢀaꢀString

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self):

ꢀꢀꢀꢀꢀꢀꢀꢀself.\_\_vowelsꢀ=ꢀ{"a"ꢀ:ꢀTrue,ꢀ"e"ꢀ:ꢀTrue,ꢀ"i"ꢀ:ꢀTrue,ꢀ"o"

ꢀ:ꢀTrue,ꢀ"u"ꢀ:ꢀTrue,ꢀ"A"ꢀ:ꢀTrue,ꢀ"E"ꢀ:ꢀTrue,ꢀ"I"ꢀ:ꢀTrue,ꢀ"O"ꢀ:ꢀT

rue,ꢀ"U"ꢀ:ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀTrue,}

ꢀꢀꢀꢀdefꢀreverseVowels(self,ꢀs):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀs:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀsꢀ==ꢀNoneꢀorꢀsꢀ==ꢀ""ꢀorꢀlen(s)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀs

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀi=0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀlen(s)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsꢀ=ꢀlist(s)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀj:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀs[i]ꢀnotꢀinꢀself.\_\_vowels:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcontinue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀs[j]ꢀnotꢀinꢀself.\_\_vowels:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcontinue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀs[i],ꢀs[j]ꢀ=ꢀs[j],ꢀs[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ"".join(s)

170





IntersectionꢀofꢀTwoꢀArrays

IntersectionꢀofꢀTwoꢀArrays

Givenꢀtwoꢀarrays,ꢀwriteꢀaꢀfunctionꢀtoꢀcomputeꢀtheirꢀintersection.

Example:ꢀGivenꢀnums1ꢀ=ꢀ[1,ꢀ2,ꢀ2,ꢀ1],ꢀnums2ꢀ=ꢀ[2,ꢀ2],ꢀreturnꢀ[2].

Note:ꢀEachꢀelementꢀinꢀtheꢀresultꢀmustꢀbeꢀunique.ꢀTheꢀresultꢀcanꢀbeꢀinꢀanyꢀorder.

URL:ꢀhttps://leetcode.com/problems/intersection-of-two-arrays/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀintersection(self,ꢀnums1,ꢀnums2):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums1:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums2:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀnums1ꢀ=ꢀsorted(nums1)

ꢀꢀꢀꢀꢀꢀꢀꢀnums2ꢀ=ꢀsorted(nums2)

ꢀꢀꢀꢀꢀꢀꢀꢀintersectionꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀlen(nums1)ꢀandꢀjꢀ<ꢀlen(nums2):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums1[i]ꢀ<ꢀnums2[j]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀnums2[j]ꢀ<ꢀnums1[i]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀintersection[nums1[i]]ꢀ=ꢀnums1[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀintersection.keys()

171





ContainerꢀWithꢀMostꢀWater

ContainerꢀWithꢀMostꢀWater

Givennnon-negativeꢀintegersa1,a2,ꢀ...,an,ꢀwhereꢀeachꢀrepresentsꢀaꢀpointꢀat

coordinateꢀ(i,ai).nverticalꢀlinesꢀareꢀdrawnꢀsuchꢀthatꢀtheꢀtwoꢀendpointsꢀofꢀlineiisꢀat

(i,ai)ꢀandꢀ(i,ꢀ0).ꢀFindꢀtwoꢀlines,ꢀwhichꢀtogetherꢀwithꢀx-axisꢀformsꢀaꢀcontainer,ꢀsuch

thatꢀtheꢀcontainerꢀcontainsꢀtheꢀmostꢀwater.

Note:ꢀYouꢀmayꢀnotꢀslantꢀtheꢀcontainerꢀandꢀnꢀisꢀatꢀleastꢀ2.

URL:ꢀhttps://leetcode.com/problems/container-with-most-water/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmaxArea(self,ꢀheight):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀheight:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀmax\_areaꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀlen(height)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀi<j:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_areaꢀ=ꢀmax(max\_area,ꢀmin(height[i],ꢀheight[j])\*(

j-i))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀheight[i]ꢀ<ꢀheight[j]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax\_area

172





ProductꢀofꢀArrayꢀExceptꢀSelf

Givenꢀanꢀarrayꢀofnintegersꢀwheren>ꢀ1, ꢀnumsꢀ,ꢀreturnꢀanꢀarray ꢀoutputꢀsuch

that ꢀoutput[i]ꢀisꢀequalꢀtoꢀtheꢀproductꢀofꢀallꢀtheꢀelements

of ꢀnumsꢀexcept ꢀnums[i]ꢀ.

SolveꢀitwithoutꢀdivisionandꢀinꢀO(n).

Forꢀexample,ꢀgiven ꢀ[1,2,3,4]ꢀ,ꢀreturn ꢀ[24,12,8,6]ꢀ.

Followꢀup:

Couldꢀyouꢀsolveꢀitꢀwithꢀconstantꢀspaceꢀcomplexity?ꢀ(Note:ꢀTheꢀoutputꢀarraydoes

notcountꢀasꢀextraꢀspaceꢀforꢀtheꢀpurposeꢀofꢀspaceꢀcomplexityꢀanalysis.)

URL:ꢀhttps://leetcode.com/problems/product-of-array-except-self/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀproductExceptSelf(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀbeforeꢀ=ꢀ[1]\*len(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀafterꢀ=ꢀ[1]\*len(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀproductꢀ=ꢀ[0]\*len(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀlen(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbefore[i]ꢀ=ꢀbefore[i-1]\*nums[i-1]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)-2,ꢀ-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀafter[i]ꢀ=ꢀafter[i+1]\*nums[i+1]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀproduct[i]ꢀ=ꢀbefore[i]\*after[i]

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀproduct

173





TrappingꢀRainꢀWater

Givenꢀnꢀnon-negativeꢀintegersꢀrepresentingꢀanꢀelevationꢀmapꢀwhereꢀtheꢀwidthꢀof

eachꢀbarꢀisꢀ1,ꢀcomputeꢀhowꢀmuchꢀwaterꢀitꢀisꢀableꢀtoꢀtrapꢀafterꢀraining.

Forꢀexample,

Given ꢀ[0,1,0,2,1,0,1,3,2,1,2,1]ꢀ,ꢀreturn ꢀ6ꢀ.

Theꢀaboveꢀelevationꢀmapꢀisꢀrepresentedꢀbyꢀarrayꢀ[0,1,0,2,1,0,1,3,2,1,2,1].ꢀInꢀthis

case,ꢀ6ꢀunitsꢀofꢀrainꢀwaterꢀ(blueꢀsection)ꢀareꢀbeingꢀtrapped.ThanksꢀMarcosꢀfor

contributingꢀthisꢀimage!

URL:ꢀhttps://leetcode.com/problems/trapping-rain-water/

174





TrappingꢀRainꢀWater

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀtrap(self,ꢀheight):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀheight:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀmaxseenrightꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀmaxseenright\_arrꢀ=ꢀ[0]\*len(height)

ꢀꢀꢀꢀꢀꢀꢀꢀmaxseenleftꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀrainwaterꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(height)ꢀ-ꢀ1,ꢀ-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀheight[i]ꢀ>ꢀmaxseenright:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmaxseenright\_arr[i]ꢀ=ꢀheight[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmaxseenrightꢀ=ꢀheight[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmaxseenright\_arr[i]ꢀ=ꢀmaxseenright

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(height)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrainwaterꢀ=ꢀrainwaterꢀ+ꢀmax(min(maxseenright\_arr[i],

ꢀmaxseenleft)ꢀ-ꢀheight[i],0)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀheight[i]ꢀ>ꢀmaxseenleft:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmaxseenleftꢀ=ꢀheight[i]

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀrainwater

175





MaximumꢀSubarray

Findꢀtheꢀcontiguousꢀsubarrayꢀwithinꢀanꢀarrayꢀ(containingꢀatꢀleastꢀoneꢀnumber)

whichꢀhasꢀtheꢀlargestꢀsum.

Forꢀexample,ꢀgivenꢀtheꢀarray ꢀ[-2,1,-3,4,-1,2,1,-5,4]ꢀ,

theꢀcontiguousꢀsubarray ꢀ[4,-1,2,1]ꢀhasꢀtheꢀlargestꢀsumꢀ= ꢀ6ꢀ.

URL:ꢀhttps://leetcode.com/problems/maximum-subarray/

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmaxSubArray(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnumsꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnums[0]

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax(nums[0],ꢀnums[1],ꢀnums[0]+nums[1])

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀall\_negꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀentriesꢀ>=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀall\_negꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀall\_negꢀ==ꢀFalse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_sumꢀ=ꢀ-ꢀsys.maxsizeꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ+=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_sumꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_sumꢀ>ꢀmax\_sum:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmax\_sumꢀ=ꢀcurr\_sum

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax\_sum

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmax(nums)

176





MaximumꢀSubarray

177





BestꢀTimeꢀtoꢀBuyꢀandꢀSellꢀStockꢀII

Sayꢀyouꢀhaveꢀanꢀarrayꢀforꢀwhichꢀtheithelementꢀisꢀtheꢀpriceꢀofꢀaꢀgivenꢀstockꢀon

dayi.

Designꢀanꢀalgorithmꢀtoꢀfindꢀtheꢀmaximumꢀprofit.ꢀYouꢀmayꢀcompleteꢀasꢀmany

transactionsꢀasꢀyouꢀlikeꢀ(ie,ꢀbuyꢀoneꢀandꢀsellꢀoneꢀshareꢀofꢀtheꢀstockꢀmultiple

times).ꢀHowever,ꢀyouꢀmayꢀnotꢀengageꢀinꢀmultipleꢀtransactionsꢀatꢀtheꢀsameꢀtime

(ie,ꢀyouꢀmustꢀsellꢀtheꢀstockꢀbeforeꢀyouꢀbuyꢀagain).

URL:ꢀhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmaxProfit(self,ꢀprices):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀprices:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀpricesꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprofitꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀlen(prices)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr\_profitꢀ=ꢀprices[i]ꢀ-ꢀprices[i-1]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀcurr\_profitꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀprofitꢀ+=ꢀcurr\_profit

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀprofit

178





FindꢀMinimumꢀinꢀRotatedꢀSortedꢀArray

Supposeꢀaꢀsortedꢀarrayꢀisꢀrotatedꢀatꢀsomeꢀpivotꢀunknownꢀtoꢀyouꢀbeforehand.

(i.e., ꢀ0ꢀ1ꢀ2ꢀ4ꢀ5ꢀ6ꢀ7ꢀmightꢀbecome ꢀ4ꢀ5ꢀ6ꢀ7ꢀ0ꢀ1ꢀ2ꢀ).

Findꢀtheꢀminimumꢀelement.

Youꢀmayꢀassumeꢀnoꢀduplicateꢀexistsꢀinꢀtheꢀarray.

URL:ꢀhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀfindMin(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(nums)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmidꢀ=ꢀstartꢀ+ꢀ(endꢀ-ꢀstart)//ꢀ2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[mid]ꢀ>=ꢀnums[end]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀmidꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀmid

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnums[start]

179





Pascal'sꢀTriangle

GivenꢀnumꢀRows,ꢀgenerateꢀtheꢀfirstnumꢀRowsꢀofꢀPascal'sꢀtriangle.

Forꢀexample,ꢀgivennumRows=ꢀ5,

Return

[

ꢀꢀꢀꢀꢀ[1],

ꢀꢀꢀꢀ[1,1],

ꢀꢀꢀ[1,2,1],

ꢀꢀ[1,3,3,1],

ꢀ[1,4,6,4,1]

]

URL:ꢀhttps://leetcode.com/problems/pascals-triangle/

180





Pascal'sꢀTriangle

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgenerate(self,ꢀnumRows):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnumRows:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnumRowsꢀ<=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀpreꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀpre.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀresult.append(pre)

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀnumRows-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(0,ꢀlen(pre)-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(pre[j]+pre[j+1])ꢀꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult.append(curr)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpreꢀ=ꢀcurr

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresult

181





Pascal'sꢀTriangleꢀII

Givenꢀanꢀindexꢀk,ꢀreturnꢀtheꢀkthꢀrowꢀofꢀtheꢀPascal'sꢀtriangle.

Forꢀexample,ꢀgivenk=ꢀ3,

Return ꢀ[1,3,3,1]ꢀ.

Note:

CouldꢀyouꢀoptimizeꢀyourꢀalgorithmꢀtoꢀuseꢀonlyꢀO(k)ꢀextraꢀspace?

URL:ꢀhttps://leetcode.com/problems/pascals-triangle-ii/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgetRow(self,ꢀrowIndex):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀrowIndex:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrowIndexꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀrowIndexꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[1]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpreꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpre.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀrowIndex+1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(0,ꢀlen(pre)ꢀ-ꢀ1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(pre[j]+pre[j+1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurr.append(1)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpreꢀ=ꢀcurr

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀpre

182





SummaryꢀRanges

Givenꢀaꢀsortedꢀintegerꢀarrayꢀwithoutꢀduplicates,ꢀreturnꢀtheꢀsummaryꢀofꢀitsꢀranges.

Forꢀexample,ꢀgiven ꢀ[0,1,2,4,5,7]ꢀ,ꢀreturn ꢀ["0->2","4->5","7"].ꢀ

URL:ꢀhttps://leetcode.com/problems/summary-ranges/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsummaryRanges(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[str]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnumsꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnums

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[str(nums[0])]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀnums[0]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀnums[0]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀlen(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnums[i]ꢀ-ꢀnums[i-1]ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀres.append(self.to\_str(start,ꢀend))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀendꢀ=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀres.append(self.to\_str(start,ꢀend))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀres

ꢀꢀꢀꢀdefꢀto\_str(self,ꢀstart,ꢀend):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀstartꢀ==ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(start)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀstr(start)+"->"+str(end)

183





MissingꢀNumber

Givenꢀanꢀarrayꢀcontainingndistinctꢀnumbersꢀtakenꢀfrom ꢀ0,ꢀ1,ꢀ2,ꢀ...,ꢀnꢀ,ꢀfind

theꢀoneꢀthatꢀisꢀmissingꢀfromꢀtheꢀarray.

Forꢀexample,

Givennums= ꢀ[0,ꢀ1,ꢀ3]ꢀreturn ꢀ2ꢀ.

Note:

Yourꢀalgorithmꢀshouldꢀrunꢀinꢀlinearꢀruntimeꢀcomplexity.ꢀCouldꢀyouꢀimplementꢀit

usingꢀonlyꢀconstantꢀextraꢀspaceꢀcomplexity?

URL:ꢀhttps://leetcode.com/problems/missing-number/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmissingNumber(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prodꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prod\_indexꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)+1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prod\_indexꢀ^=ꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(nums)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prodꢀ^=ꢀnums[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀxor\_prodꢀ^ꢀxor\_prod\_index

184





ValidꢀAnagram

ValidꢀAnagram

Givenꢀtwoꢀstringsꢀsꢀandꢀt,ꢀwriteꢀaꢀfunctionꢀtoꢀdetermineꢀifꢀtꢀisꢀanꢀanagramꢀofꢀs.

Forꢀexample,ꢀsꢀ=ꢀ"anagram",ꢀtꢀ=ꢀ"nagaram",ꢀreturnꢀtrue.ꢀsꢀ=ꢀ"rat",ꢀtꢀ=ꢀ"car",ꢀreturn

false.

Note:ꢀYouꢀmayꢀassumeꢀtheꢀstringꢀcontainsꢀonlyꢀlowercaseꢀalphabets.

URL:ꢀhttps://leetcode.com/problems/valid-anagram/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisAnagram(self,ꢀs,ꢀt):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀs:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀt:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(s)ꢀ!=ꢀlen(t):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀsorted(s)ꢀ==ꢀsorted(t):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

185





ValidꢀPalindrome

ValidꢀPalindrome

Givenꢀaꢀstring,ꢀdetermineꢀifꢀitꢀisꢀaꢀpalindrome,ꢀconsideringꢀonlyꢀalphanumeric

charactersꢀandꢀignoringꢀcases.

Forꢀexample,ꢀ"Aꢀman,ꢀaꢀplan,ꢀaꢀcanal:ꢀPanama"ꢀisꢀaꢀpalindrome.ꢀ"raceꢀaꢀcar"ꢀis

notꢀaꢀpalindrome.

Note:ꢀHaveꢀyouꢀconsiderꢀthatꢀtheꢀstringꢀmightꢀbeꢀempty?ꢀThisꢀisꢀaꢀgoodꢀquestion

toꢀaskꢀduringꢀanꢀinterview.

Forꢀtheꢀpurposeꢀofꢀthisꢀproblem,ꢀweꢀdefineꢀemptyꢀstringꢀasꢀvalidꢀpalindrome.

URL:ꢀhttps://leetcode.com/problems/valid-palindrome/

importꢀre

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{string}ꢀs

ꢀꢀꢀꢀ#ꢀ@returnꢀ{boolean}

ꢀꢀꢀꢀdefꢀisPalindrome(self,ꢀs):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(s)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsꢀ=ꢀs.lower()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnewSꢀ=ꢀre.sub(r"[^a-zA-Z0-9]","",s)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀlen(newS)-1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀstartꢀ<ꢀend:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnewS[start]ꢀ==ꢀnewS[end]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstartꢀ=ꢀstartꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀendꢀ=ꢀendꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

186





WordꢀPattern

WordꢀPattern

Givenꢀaꢀpatternꢀandꢀaꢀstringꢀstr,ꢀfindꢀifꢀstrꢀfollowsꢀtheꢀsameꢀpattern.

Hereꢀfollowꢀmeansꢀaꢀfullꢀmatch,ꢀsuchꢀthatꢀthereꢀisꢀaꢀbijectionꢀbetweenꢀaꢀletterꢀin

patternꢀandꢀaꢀnon-emptyꢀwordꢀinꢀstr.

Examples:ꢀpatternꢀ=ꢀ"abba",ꢀstrꢀ=ꢀ"dogꢀcatꢀcatꢀdog"ꢀshouldꢀreturnꢀtrue.ꢀpatternꢀ=

"abba",ꢀstrꢀ=ꢀ"dogꢀcatꢀcatꢀfish"ꢀshouldꢀreturnꢀfalse.ꢀpatternꢀ=ꢀ"aaaa",ꢀstrꢀ=ꢀ"dogꢀcat

catꢀdog"ꢀshouldꢀreturnꢀfalse.ꢀpatternꢀ=ꢀ"abba",ꢀstrꢀ=ꢀ"dogꢀdogꢀdogꢀdog"ꢀshould

returnꢀfalse.ꢀNotes:ꢀYouꢀmayꢀassumeꢀpatternꢀcontainsꢀonlyꢀlowercaseꢀletters,ꢀand

strꢀcontainsꢀlowercaseꢀlettersꢀseparatedꢀbyꢀaꢀsingleꢀspace.

URL:ꢀhttps://leetcode.com/problems/word-pattern/

187





WordꢀPattern

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀwordPattern(self,ꢀpattern,ꢀstr):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀpattern:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀstr:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀpatternꢀ==ꢀNoneꢀorꢀstrꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_strꢀ=ꢀlen(str.split("ꢀ"))

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlen\_patternꢀ=ꢀlen(pattern)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen\_strꢀ!=ꢀlen\_pattern:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstrꢀ=ꢀstr.split("ꢀ")

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookupꢀ=ꢀ{}

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(pattern)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsꢀ=ꢀstr[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpꢀ=ꢀpattern[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀpꢀinꢀlookup:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlookup[p]ꢀ!=ꢀs:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀsꢀinꢀlookup.values():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookup[p]ꢀ=ꢀs

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ifꢀ\_\_name\_\_ꢀ==ꢀ"\_\_main\_\_":

ꢀꢀꢀꢀpatternꢀ=ꢀ"abba"

ꢀꢀꢀꢀstrꢀ=ꢀ"dogꢀcatꢀcatꢀdog"

ꢀꢀꢀꢀsolnꢀ=ꢀSolution()

ꢀꢀꢀꢀprint(soln.wordPattern(pattern,ꢀstr))

188





ValidꢀParentheses

ValidꢀParentheses

Givenꢀaꢀstringꢀcontainingꢀjustꢀtheꢀcharactersꢀ'(',ꢀ')',ꢀ'{',ꢀ'}',ꢀ'['ꢀandꢀ']',ꢀdetermineꢀifꢀthe

inputꢀstringꢀisꢀvalid.

Theꢀbracketsꢀmustꢀcloseꢀinꢀtheꢀcorrectꢀorder,ꢀ"()"ꢀandꢀ"()[]{}"ꢀareꢀallꢀvalidꢀbutꢀ"(]"

andꢀ"([)]"ꢀareꢀnot.

URL:ꢀhttps://leetcode.com/problems/valid-parentheses/

189





ValidꢀParentheses

classꢀSolution:

ꢀꢀꢀꢀ#ꢀ@paramꢀ{string}ꢀs

ꢀꢀꢀꢀ#ꢀ@returnꢀ{boolean}

ꢀꢀꢀꢀdefꢀisValid(self,ꢀs):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀsꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstackꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbalancedꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀindexꢀ<ꢀlen(s)ꢀandꢀbalanced:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsymbolꢀ=ꢀs[index]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀsymbolꢀinꢀ"({[":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀstack.append(symbol)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀstackꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbalancedꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopꢀ=ꢀstack.pop()

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀnotꢀself.matches(top,symbol):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀbalancedꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ=ꢀindexꢀ+ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀbalancedꢀandꢀstackꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀdefꢀmatches(self,open,close):

ꢀꢀꢀꢀꢀꢀꢀꢀopeningsꢀ=ꢀ"({["

ꢀꢀꢀꢀꢀꢀꢀꢀclosingsꢀ=ꢀ")}]"

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀopenings.index(open)ꢀ==ꢀclosings.index(close)

190





IsomorphicꢀStrings

IsomorphicꢀStrings

Givenꢀtwoꢀstringsꢀsꢀandꢀt,ꢀdetermineꢀifꢀtheyꢀareꢀisomorphic.

Twoꢀstringsꢀareꢀisomorphicꢀifꢀtheꢀcharactersꢀinꢀsꢀcanꢀbeꢀreplacedꢀtoꢀgetꢀt.

Allꢀoccurrencesꢀofꢀaꢀcharacterꢀmustꢀbeꢀreplacedꢀwithꢀanotherꢀcharacterꢀwhile

preservingꢀtheꢀorderꢀofꢀcharacters.ꢀNoꢀtwoꢀcharactersꢀmayꢀmapꢀtoꢀtheꢀsame

characterꢀbutꢀaꢀcharacterꢀmayꢀmapꢀtoꢀitself.

Forꢀexample,ꢀGivenꢀ"egg",ꢀ"add",ꢀreturnꢀtrue.

Givenꢀ"foo",ꢀ"bar",ꢀreturnꢀfalse.

Givenꢀ"paper",ꢀ"title",ꢀreturnꢀtrue.

Note:ꢀYouꢀmayꢀassumeꢀbothꢀsꢀandꢀtꢀhaveꢀtheꢀsameꢀlength.

URL:ꢀhttps://leetcode.com/problems/isomorphic-strings/

191





IsomorphicꢀStrings

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisIsomorphic(self,ꢀs,ꢀt):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀs:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀt:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀsꢀ==ꢀNoneꢀorꢀtꢀ==ꢀNone:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀsꢀ==ꢀ""ꢀandꢀtꢀ==ꢀ"":

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(s)ꢀ!=ꢀlen(t):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookupꢀ=ꢀ{}ꢀꢀꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀlen(s)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀc1ꢀ=ꢀs[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀc2ꢀ=ꢀt[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀc1ꢀinꢀlookup:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlookup[c1]ꢀ!=ꢀc2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀc2ꢀinꢀlookup.values():

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlookup[c1]ꢀ=ꢀc2

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

192





ReverseꢀString

ReverseꢀString

Writeꢀaꢀfunctionꢀthatꢀtakesꢀaꢀstringꢀasꢀinputꢀandꢀreturnsꢀtheꢀstringꢀreversed.

Example:ꢀGivenꢀsꢀ=ꢀ"hello",ꢀreturnꢀ"olleh".

URL:ꢀhttps://leetcode.com/problems/reverse-string/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀreverseString(self,ꢀs):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀs:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀstr

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀcurrent\_strꢀ=ꢀ[charꢀforꢀcharꢀinꢀs]

ꢀꢀꢀꢀꢀꢀꢀꢀiꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀjꢀ=ꢀlen(s)ꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀiꢀ<ꢀj:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtempꢀ=ꢀcurrent\_str[i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrent\_str[i]ꢀ=ꢀcurrent\_str[j]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcurrent\_str[j]ꢀ=ꢀtemp

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀjꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀiꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ"".join(current\_str)

193





SumꢀofꢀTwoꢀIntegers

SumꢀofꢀTwoꢀIntegers

Calculateꢀtheꢀsumꢀofꢀtwoꢀintegersꢀaꢀandꢀb,ꢀbutꢀyouꢀareꢀnotꢀallowedꢀtoꢀuseꢀthe

operatorꢀ+ꢀandꢀ-.

Example:ꢀGivenꢀaꢀ=ꢀ1ꢀandꢀbꢀ=ꢀ2,ꢀreturnꢀ3.

URL:ꢀhttps://leetcode.com/problems/sum-of-two-integers/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgetSum(self,ꢀa,ꢀb):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀa:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀb:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀbꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀa

ꢀꢀꢀꢀꢀꢀꢀꢀsumꢀ=ꢀaꢀ^ꢀb

ꢀꢀꢀꢀꢀꢀꢀꢀcarryꢀ=ꢀ(aꢀ&ꢀb)ꢀ<<ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.getSum(sum,ꢀcarry)

194





SingleꢀNumber

SingleꢀNumber

Givenꢀanꢀarrayꢀofꢀintegers,ꢀeveryꢀelementꢀappearsꢀtwiceꢀexceptꢀforꢀone.ꢀFindꢀthat

singleꢀone.

Note:ꢀYourꢀalgorithmꢀshouldꢀhaveꢀaꢀlinearꢀruntimeꢀcomplexity.ꢀCouldꢀyou

implementꢀitꢀwithoutꢀusingꢀextraꢀmemory?

URL:ꢀhttps://leetcode.com/problems/single-number/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsingleNumber(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(nums)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀNone

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(nums)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀnums[0]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prodꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀentriesꢀinꢀnums:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxor\_prodꢀ^=ꢀentriesꢀ

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀxor\_prod

195





ReverseꢀInteger

ReverseꢀInteger

Reverseꢀdigitsꢀofꢀanꢀinteger.

Example1:ꢀxꢀ=ꢀ123,ꢀreturnꢀ321ꢀExample2:ꢀxꢀ=ꢀ-123,ꢀreturnꢀ-321

clickꢀtoꢀshowꢀspoilers.

Haveꢀyouꢀthoughtꢀaboutꢀthis?ꢀHereꢀareꢀsomeꢀgoodꢀquestionsꢀtoꢀaskꢀbefore

coding.ꢀBonusꢀpointsꢀforꢀyouꢀifꢀyouꢀhaveꢀalreadyꢀthoughtꢀthroughꢀthis!

Ifꢀtheꢀinteger'sꢀlastꢀdigitꢀisꢀ0,ꢀwhatꢀshouldꢀtheꢀoutputꢀbe?ꢀie,ꢀcasesꢀsuchꢀasꢀ10,

\100.

Didꢀyouꢀnoticeꢀthatꢀtheꢀreversedꢀintegerꢀmightꢀoverflow?ꢀAssumeꢀtheꢀinputꢀisꢀaꢀ32-

bitꢀinteger,ꢀthenꢀtheꢀreverseꢀofꢀ1000000003ꢀoverflows.ꢀHowꢀshouldꢀyouꢀhandle

suchꢀcases?

Forꢀtheꢀpurposeꢀofꢀthisꢀproblem,ꢀassumeꢀthatꢀyourꢀfunctionꢀreturnsꢀ0ꢀwhenꢀthe

reversedꢀintegerꢀoverflows.

URL:ꢀhttps://leetcode.com/problems/reverse-integer/

importꢀsys

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀreverse(self,ꢀx):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀx:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀxꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-self.reverse(-x)

ꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀx:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀresultꢀ\*ꢀ10ꢀ+ꢀxꢀ%ꢀ10

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀxꢀ/=ꢀ10

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresultꢀifꢀresultꢀ<=ꢀ0x7fffffffꢀelseꢀ0

196





ReverseꢀInteger

197





PalindromeꢀNumber

PalindromeꢀNumber

Determineꢀwhetherꢀanꢀintegerꢀisꢀaꢀpalindrome.ꢀDoꢀthisꢀwithoutꢀextraꢀspace.

clickꢀtoꢀshowꢀspoilers.

Someꢀhints:ꢀCouldꢀnegativeꢀintegersꢀbeꢀpalindromes?ꢀ(ie,ꢀ-1)

Ifꢀyouꢀareꢀthinkingꢀofꢀconvertingꢀtheꢀintegerꢀtoꢀstring,ꢀnoteꢀtheꢀrestrictionꢀofꢀusing

extraꢀspace.

Youꢀcouldꢀalsoꢀtryꢀreversingꢀanꢀinteger.ꢀHowever,ꢀifꢀyouꢀhaveꢀsolvedꢀtheꢀproblem

"ReverseꢀInteger",ꢀyouꢀknowꢀthatꢀtheꢀreversedꢀintegerꢀmightꢀoverflow.ꢀHowꢀwould

youꢀhandleꢀsuchꢀcase?

Thereꢀisꢀaꢀmoreꢀgenericꢀwayꢀofꢀsolvingꢀthisꢀproblem.

URL:ꢀhttps://leetcode.com/problems/palindrome-number/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisPalindrome(self,ꢀx):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀx:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀxꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀrevꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀcopyꢀ=ꢀx

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀcopyꢀ!=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrevꢀ=ꢀrev\*10ꢀ+ꢀcopy%10

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcopyꢀ=ꢀcopy/10

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀrevꢀ==ꢀx:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

198





PalindromeꢀNumber

199





Pow(x,n)

Pow(x,n)

Implementꢀpow(x,ꢀn).

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀmyPow(self,ꢀx,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀx:ꢀfloat

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀfloat

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ<ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1/self.power(x,ꢀ-n)

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀself.power(x,ꢀn)

ꢀꢀꢀꢀdefꢀpower(self,ꢀx,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀvꢀ=ꢀself.power(x,ꢀn//2)

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ%ꢀ2ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀvꢀ\*ꢀv

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀvꢀ\*ꢀvꢀ\*ꢀx

200





Subsets

Subsets

Givenꢀaꢀsetꢀofꢀdistinctꢀintegers,ꢀnums,ꢀreturnꢀallꢀpossibleꢀsubsets.

Note:ꢀTheꢀsolutionꢀsetꢀmustꢀnotꢀcontainꢀduplicateꢀsubsets.

Forꢀexample,ꢀIfꢀnumsꢀ=ꢀ[1,2,3],ꢀaꢀsolutionꢀis:

[ꢀ[3],ꢀ[1],ꢀ[2],ꢀ[1,2,3],ꢀ[1,3],ꢀ[2,3],ꢀ[1,2],ꢀ[]ꢀ]

URL:ꢀhttps://leetcode.com/problems/subsets/

Solution1:

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsubsets(self,ꢀS):

ꢀꢀꢀꢀꢀꢀꢀꢀdefꢀdfs(depth,ꢀstart,ꢀvaluelist):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀres.append(valuelist)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀdepthꢀ==ꢀlen(S):ꢀreturn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(start,ꢀlen(S)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdfs(depth+1,ꢀi+1,ꢀvaluelist+[S[i]])

ꢀꢀꢀꢀꢀꢀꢀꢀS.sort()

ꢀꢀꢀꢀꢀꢀꢀꢀresꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀdfs(0,ꢀ0,ꢀ[])

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀres

Solution2:

201





Subsets

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsubsets(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀnꢀ=ꢀ1ꢀ<<ꢀlen(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsubsetꢀ=ꢀself.convert(i,ꢀnums)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult.append(subset)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀresult

ꢀꢀꢀꢀdefꢀconvert(self,ꢀi,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀkꢀ=ꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀresꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀkꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(kꢀ&ꢀ1)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀres.append(nums[index])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ>>=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀres

202





SubsetsꢀII

SubsetsꢀII

Givenꢀaꢀcollectionꢀofꢀintegersꢀthatꢀmightꢀcontainꢀduplicates,ꢀnums,ꢀreturnꢀall

possibleꢀsubsets.

Note:ꢀTheꢀsolutionꢀsetꢀmustꢀnotꢀcontainꢀduplicateꢀsubsets.

Forꢀexample,ꢀIfꢀnumsꢀ=ꢀ[1,2,2],ꢀaꢀsolutionꢀis:

[ꢀ[2],ꢀ[1],ꢀ[1,2,2],ꢀ[2,2],ꢀ[1,2],ꢀ[]ꢀ]

URL:ꢀhttps://leetcode.com/problems/subsets-ii/

203





SubsetsꢀII

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsubsetsWithDup(self,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀnums:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀnꢀ=ꢀ1ꢀ<<ꢀlen(nums)

ꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(0,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀsubsetꢀ=ꢀself.convert(i,ꢀnums)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀresult.append(tuple(sorted(subset)))

ꢀꢀꢀꢀꢀꢀꢀꢀresultꢀ=ꢀset(result)

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[list(entries)ꢀforꢀentriesꢀinꢀresult]

ꢀꢀꢀꢀdefꢀconvert(self,ꢀi,ꢀnums):

ꢀꢀꢀꢀꢀꢀꢀꢀkꢀ=ꢀi

ꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀresꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀkꢀ>ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(kꢀ&ꢀ1)ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀres.append(nums[index])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ>>=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀindexꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀres

204





PowerꢀofꢀThree

PowerꢀofꢀThree

205





SelfꢀCrossing

SelfꢀCrossing

Youꢀareꢀgivenꢀanꢀarrayꢀxꢀofꢀnꢀpositiveꢀnumbers.ꢀYouꢀstartꢀatꢀpointꢀ(0,0)ꢀandꢀmoves

x[0]ꢀmetresꢀtoꢀtheꢀnorth,ꢀthenꢀx[1]ꢀmetresꢀtoꢀtheꢀwest,ꢀx[2]ꢀmetresꢀtoꢀtheꢀsouth,ꢀx[3]

metresꢀtoꢀtheꢀeastꢀandꢀsoꢀon.ꢀInꢀotherꢀwords,ꢀafterꢀeachꢀmoveꢀyourꢀdirection

changesꢀcounter-clockwise.

Writeꢀaꢀone-passꢀalgorithmꢀwithꢀO(1)ꢀextraꢀspaceꢀtoꢀdetermine,ꢀifꢀyourꢀpath

crossesꢀitself,ꢀorꢀnot.

Exampleꢀ1:ꢀGivenꢀxꢀ=ꢀ[2,ꢀ1,ꢀ1,ꢀ2],ꢀ┌───┐ꢀ│ꢀ│ꢀ└───┼──>ꢀ│

Returnꢀtrueꢀ(selfꢀcrossing)ꢀExampleꢀ2:ꢀGivenꢀxꢀ=ꢀ[1,ꢀ2,ꢀ3,ꢀ4],ꢀ┌──────┐ꢀ│ꢀ│ꢀ│ꢀ│

└────────────>

Returnꢀfalseꢀ(notꢀselfꢀcrossing)ꢀExampleꢀ3:ꢀGivenꢀxꢀ=ꢀ[1,ꢀ1,ꢀ1,ꢀ1],ꢀ┌───┐ꢀ│ꢀ│

└───┼>

Returnꢀtrueꢀ(selfꢀcrossing)

URL:ꢀhttps://leetcode.com/problems/self-crossing/

206





SelfꢀCrossing

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀisSelfCrossing(self,ꢀx):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀx:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀxꢀ==ꢀNoneꢀorꢀlen(x)ꢀ<=ꢀ3:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(3,ꢀlen(x)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(x[i-3]ꢀ>=ꢀx[i-1])ꢀandꢀ(x[i-2]ꢀ<=ꢀx[i]):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(iꢀ>=ꢀ4)ꢀandꢀ(x[i-4]ꢀ+ꢀx[i]ꢀ>=ꢀx[i-2])ꢀandꢀ(x

[i-3]ꢀ==ꢀx[i-1]):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀ(i>=5)ꢀandꢀ(x[i-5]ꢀ<=ꢀx[i-3])ꢀandꢀ(x[i-4]ꢀ<=ꢀ

x[i-2])ꢀandꢀ(x[i-1]ꢀ<=ꢀx[i-3])ꢀandꢀ(x[i-1]ꢀ>=ꢀx[i-3]ꢀ-ꢀx[i-5])ꢀa

ndꢀ(x[i]ꢀ>=ꢀx[i-2]ꢀ-ꢀx[i-4])ꢀandꢀ(x[i]ꢀ<=ꢀx[i-2]):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

207





PaintꢀFence

PaintꢀFence

Thereꢀisꢀaꢀfenceꢀwithꢀnꢀposts,ꢀeachꢀpostꢀcanꢀbeꢀpaintedꢀwithꢀoneꢀofꢀtheꢀkꢀcolors.

Youꢀhaveꢀtoꢀpaintꢀallꢀtheꢀpostsꢀsuchꢀthatꢀnoꢀmoreꢀthanꢀtwoꢀadjacentꢀfenceꢀposts

haveꢀtheꢀsameꢀcolor.

Returnꢀtheꢀtotalꢀnumberꢀofꢀwaysꢀyouꢀcanꢀpaintꢀtheꢀfence.

Note:ꢀnꢀandꢀkꢀareꢀnon-negativeꢀintegers.

URL:ꢀhttps://leetcode.com/problems/paint-fence/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀnumWays(self,ꢀn,ꢀk):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀk:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀdpꢀ=ꢀ[0,ꢀk,ꢀk\*k,ꢀ0]

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ<=ꢀ2:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdp[n]

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(2,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdp[3]ꢀ=ꢀ(k-1)\*(dp[1]ꢀ+ꢀdp[2])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdp[1]ꢀ=ꢀdp[2]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀdp[2]ꢀ=ꢀdp[3]

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀdp[3]

208





BulbꢀSwitcher

BulbꢀSwitcher

Thereꢀareꢀnꢀbulbsꢀthatꢀareꢀinitiallyꢀoff.ꢀYouꢀfirstꢀturnꢀonꢀallꢀtheꢀbulbs.ꢀThen,ꢀyouꢀturn

offꢀeveryꢀsecondꢀbulb.ꢀOnꢀtheꢀthirdꢀround,ꢀyouꢀtoggleꢀeveryꢀthirdꢀbulbꢀ(turningꢀonꢀif

it'sꢀoffꢀorꢀturningꢀoffꢀifꢀit'sꢀon).ꢀForꢀtheꢀithꢀround,ꢀyouꢀtoggleꢀeveryꢀiꢀbulb.ꢀForꢀtheꢀnth

round,ꢀyouꢀonlyꢀtoggleꢀtheꢀlastꢀbulb.ꢀFindꢀhowꢀmanyꢀbulbsꢀareꢀonꢀafterꢀnꢀrounds.

Example:

Givenꢀnꢀ=ꢀ3.

Atꢀfirst,ꢀtheꢀthreeꢀbulbsꢀareꢀ[off,ꢀoff,ꢀoff].ꢀAfterꢀfirstꢀround,ꢀtheꢀthreeꢀbulbsꢀareꢀ[on,

on,ꢀon].ꢀAfterꢀsecondꢀround,ꢀtheꢀthreeꢀbulbsꢀareꢀ[on,ꢀoff,ꢀon].ꢀAfterꢀthirdꢀround,ꢀthe

threeꢀbulbsꢀareꢀ[on,ꢀoff,ꢀoff].

Soꢀyouꢀshouldꢀreturnꢀ1,ꢀbecauseꢀthereꢀisꢀonlyꢀoneꢀbulbꢀisꢀon.

URL:ꢀhttps://leetcode.com/problems/bulb-switcher/

importꢀmath

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀbulbSwitch(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀint(math.sqrt(n))

209





NimꢀGame

NimꢀGame

YouꢀareꢀplayingꢀtheꢀfollowingꢀNimꢀGameꢀwithꢀyourꢀfriend:ꢀThereꢀisꢀaꢀheapꢀof

stonesꢀonꢀtheꢀtable,ꢀeachꢀtimeꢀoneꢀofꢀyouꢀtakeꢀturnsꢀtoꢀremoveꢀ1ꢀtoꢀ3ꢀstones.ꢀThe

oneꢀwhoꢀremovesꢀtheꢀlastꢀstoneꢀwillꢀbeꢀtheꢀwinner.ꢀYouꢀwillꢀtakeꢀtheꢀfirstꢀturnꢀto

removeꢀtheꢀstones.

Bothꢀofꢀyouꢀareꢀveryꢀcleverꢀandꢀhaveꢀoptimalꢀstrategiesꢀforꢀtheꢀgame.ꢀWriteꢀa

functionꢀtoꢀdetermineꢀwhetherꢀyouꢀcanꢀwinꢀtheꢀgameꢀgivenꢀtheꢀnumberꢀofꢀstones

inꢀtheꢀheap.

Forꢀexample,ꢀifꢀthereꢀareꢀ4ꢀstonesꢀinꢀtheꢀheap,ꢀthenꢀyouꢀwillꢀneverꢀwinꢀtheꢀgame:

noꢀmatterꢀ1,ꢀ2,ꢀorꢀ3ꢀstonesꢀyouꢀremove,ꢀtheꢀlastꢀstoneꢀwillꢀalwaysꢀbeꢀremovedꢀby

yourꢀfriend.

Hint:

Ifꢀthereꢀareꢀ5ꢀstonesꢀinꢀtheꢀheap,ꢀcouldꢀyouꢀfigureꢀoutꢀaꢀwayꢀtoꢀremoveꢀtheꢀstones

suchꢀthatꢀyouꢀwillꢀalwaysꢀbeꢀtheꢀwinner?

URL:ꢀhttps://leetcode.com/problems/nim-game/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀcanWinNim(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀn%4ꢀ!=ꢀ0

210





RotateꢀImage

RotateꢀImage

Youꢀareꢀgivenꢀanꢀnꢀxꢀnꢀ2Dꢀmatrixꢀrepresentingꢀanꢀimage.

Rotateꢀtheꢀimageꢀbyꢀ90ꢀdegreesꢀ(clockwise).

Followꢀup:ꢀCouldꢀyouꢀdoꢀthisꢀin-place?

URL:ꢀhttps://leetcode.com/problems/rotate-image/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀrotate(self,ꢀmatrix):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀmatrixꢀin-pl

aceꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrixꢀ==ꢀNoneꢀorꢀmatrixꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnꢀ=ꢀlen(matrix)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀlayerꢀinꢀrange(0,ꢀn//2):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfirstꢀ=ꢀlayer

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlastꢀ=ꢀnꢀ-ꢀ1ꢀ-ꢀlayer

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(first,ꢀlast):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀoffsetꢀ=ꢀiꢀ-ꢀfirst

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀtopꢀ=ꢀmatrix[first][i]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[first][i]ꢀ=ꢀmatrix[lastꢀ-ꢀoffset][fir

st]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[lastꢀ-ꢀoffset][first]ꢀ=ꢀmatrix[last][

lastꢀ-ꢀoffset]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[last][lastꢀ-ꢀoffset]ꢀ=ꢀmatrix[i][last

]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][last]ꢀ=ꢀtop

211





SetꢀMatrixꢀZeroes

SetꢀMatrixꢀZeroes

Givenꢀaꢀmꢀxꢀnꢀmatrix,ꢀifꢀanꢀelementꢀisꢀ0,ꢀsetꢀitsꢀentireꢀrowꢀandꢀcolumnꢀtoꢀ0.ꢀDoꢀitꢀin

place.

clickꢀtoꢀshowꢀfollowꢀup.

Followꢀup:ꢀDidꢀyouꢀuseꢀextraꢀspace?ꢀAꢀstraightꢀforwardꢀsolutionꢀusingꢀO(mn)

spaceꢀisꢀprobablyꢀaꢀbadꢀidea.ꢀAꢀsimpleꢀimprovementꢀusesꢀO(mꢀ+ꢀn)ꢀspace,ꢀbutꢀstill

notꢀtheꢀbestꢀsolution.ꢀCouldꢀyouꢀdeviseꢀaꢀconstantꢀspaceꢀsolution?

URL:ꢀhttps://leetcode.com/problems/set-matrix-zeroes/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsetZeroes(self,ꢀmatrix):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀmatrixꢀin-pl

aceꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrixꢀ==ꢀNoneꢀorꢀlen(matrix)ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀlen(matrix)ꢀ==ꢀ1ꢀandꢀlen(matrix[0])ꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀpass

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrows\_with\_0ꢀ=ꢀ[False]\*len(matrix)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcols\_with\_0ꢀ=ꢀ[False]\*len(matrix[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(len(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[i][j]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrows\_with\_0[i]ꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcols\_with\_0[j]ꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(len(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀrows\_with\_0[i]ꢀorꢀcols\_with\_0[j]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][j]ꢀ=ꢀ0

212





SetꢀMatrixꢀZeroes

ConstantꢀSpaceꢀSolution:

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsetZeroes(self,ꢀmatrix):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀvoidꢀDoꢀnotꢀreturnꢀanything,ꢀmodifyꢀmatrixꢀin-pl

aceꢀinstead.

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀfirst\_rowꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀfirst\_colꢀ=ꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(len(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[0][j]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfirst\_rowꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[i][0]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀfirst\_colꢀ=ꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀlen(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(1,ꢀlen(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[i][j]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][0]ꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[0][j]ꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(1,ꢀlen(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀjꢀinꢀrange(1,ꢀlen(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[i][0]ꢀ==ꢀ0ꢀorꢀmatrix[0][j]ꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][j]ꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfirst\_col:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(matrix)):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][0]ꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀfirst\_row:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(len(matrix[0])):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[0][i]ꢀ=ꢀ0

213





SetꢀMatrixꢀZeroes

214





Searchꢀaꢀ2DꢀMatrix

Searchꢀaꢀ2DꢀMatrix

Writeꢀanꢀefficientꢀalgorithmꢀthatꢀsearchesꢀforꢀaꢀvalueꢀinꢀanꢀmꢀxꢀnꢀmatrix.ꢀThis

matrixꢀhasꢀtheꢀfollowingꢀproperties:

Integersꢀinꢀeachꢀrowꢀareꢀsortedꢀfromꢀleftꢀtoꢀright.ꢀTheꢀfirstꢀintegerꢀofꢀeachꢀrowꢀis

greaterꢀthanꢀtheꢀlastꢀintegerꢀofꢀtheꢀpreviousꢀrow.ꢀForꢀexample,

Considerꢀtheꢀfollowingꢀmatrix:

[ꢀ[1,ꢀ3,ꢀ5,ꢀ7],ꢀ[10,ꢀ11,ꢀ16,ꢀ20],ꢀ[23,ꢀ30,ꢀ34,ꢀ50]ꢀ]ꢀGivenꢀtargetꢀ=ꢀ3,ꢀreturnꢀtrue.

215





Searchꢀaꢀ2DꢀMatrix

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsearchMatrix(self,ꢀmatrix,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrixꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀno\_rowsꢀ=ꢀlen(matrix)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀno\_colsꢀ=ꢀlen(matrix[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#getꢀtheꢀfirstꢀelementꢀandꢀtheꢀlastꢀelementꢀofꢀtheꢀm

atrix

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#compareꢀitꢀwithꢀtheꢀtarget

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀtargetꢀ<ꢀmatrix[0][0]ꢀorꢀtargetꢀ>ꢀmatrix[no\_rows-

1][no\_cols-1]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ=ꢀno\_colsꢀ-ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀrꢀ<ꢀno\_rowsꢀandꢀcꢀ>=ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀtargetꢀ==ꢀmatrix[r][c]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀtargetꢀ>ꢀmatrix[r][c]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀtargetꢀ<ꢀmatrix[r][c]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

216





Searchꢀaꢀ2DꢀMatrixꢀII

Searchꢀaꢀ2DꢀMatrixꢀII

Writeꢀanꢀefficientꢀalgorithmꢀthatꢀsearchesꢀforꢀaꢀvalueꢀinꢀanꢀmꢀxꢀnꢀmatrix.ꢀThis

matrixꢀhasꢀtheꢀfollowingꢀproperties:

Integersꢀinꢀeachꢀrowꢀareꢀsortedꢀinꢀascendingꢀfromꢀleftꢀtoꢀright.ꢀIntegersꢀinꢀeach

columnꢀareꢀsortedꢀinꢀascendingꢀfromꢀtopꢀtoꢀbottom.ꢀForꢀexample,

Considerꢀtheꢀfollowingꢀmatrix:

[ꢀ[1,ꢀ4,ꢀ7,ꢀ11,ꢀ15],ꢀ[2,ꢀ5,ꢀ8,ꢀ12,ꢀ19],ꢀ[3,ꢀ6,ꢀ9,ꢀ16,ꢀ22],ꢀ[10,ꢀ13,ꢀ14,ꢀ17,ꢀ24],ꢀ[18,ꢀ21,ꢀ23,

26,ꢀ30]ꢀ]ꢀGivenꢀtargetꢀ=ꢀ5,ꢀreturnꢀtrue.

Givenꢀtargetꢀ=ꢀ20,ꢀreturnꢀfalse.

URL:ꢀhttps://leetcode.com/problems/search-a-2d-matrix-ii/

217





Searchꢀaꢀ2DꢀMatrixꢀII

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀsearchMatrix(self,ꢀmatrix,ꢀtarget):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀtarget:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀbool

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrixꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀno\_rowsꢀ=ꢀlen(matrix)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀno\_colsꢀ=ꢀlen(matrix[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀtargetꢀ<ꢀmatrix[0][0]ꢀorꢀtargetꢀ>ꢀmatrix[no\_rows-

1][no\_cols-1]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ=ꢀno\_cols-1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀrꢀ<ꢀno\_rowsꢀandꢀcꢀ>=0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrix[r][c]ꢀ==ꢀtarget:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀTrue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀtargetꢀ>ꢀmatrix[r][c]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelifꢀtargetꢀ<ꢀmatrix[r][c]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀFalse

218





SpiralꢀMatrix

SpiralꢀMatrix

Givenꢀaꢀmatrixꢀofꢀmꢀxꢀnꢀelementsꢀ(mꢀrows,ꢀnꢀcolumns),ꢀreturnꢀallꢀelementsꢀofꢀthe

matrixꢀinꢀspiralꢀorder.

Forꢀexample,ꢀGivenꢀtheꢀfollowingꢀmatrix:

[ꢀ[ꢀ1,ꢀ2,ꢀ3ꢀ],ꢀ[ꢀ4,ꢀ5,ꢀ6ꢀ],ꢀ[ꢀ7,ꢀ8,ꢀ9ꢀ]ꢀ]ꢀYouꢀshouldꢀreturnꢀ[1,2,3,6,9,8,7,4,5].

URL:ꢀhttps://leetcode.com/problems/spiral-matrix/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀspiralOrder(self,ꢀmatrix):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀmatrix:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[int]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀmatrixꢀ==ꢀNoneꢀorꢀmatrixꢀ==ꢀ[]:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmatrix

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#noꢀofꢀrows

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmꢀ=ꢀlen(matrix)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#noꢀofꢀcolumns

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀnꢀ=ꢀlen(matrix[0])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#startingꢀrow

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#startingꢀcolumn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#spiralꢀorderꢀmatrix

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀspiralꢀ=ꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀkꢀ<ꢀmꢀandꢀlꢀ<ꢀn:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#printꢀtheꢀfirstꢀrowꢀfromꢀtheꢀremainingꢀrows

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(l,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀspiral.append(matrix[k][i])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#printꢀtheꢀlastꢀcolumnꢀfromꢀtheꢀremainingꢀcolumn

219





SpiralꢀMatrix

s

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(k,ꢀm):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀspiral.append(matrix[i][n-1])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀn-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#printꢀtheꢀlastꢀrowꢀfromꢀtheꢀremainingꢀrows

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀkꢀ<ꢀm:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(n-1,ꢀl-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀspiral.append(matrix[m-1][i])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#printꢀtheꢀfirstꢀcolumnꢀfromꢀtheꢀremainingꢀcolum

ns

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlꢀ<ꢀn:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(m-1,ꢀk-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀspiral.append(matrix[i][l])

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀspiral

220





SpiralꢀMatrixꢀII

SpiralꢀMatrixꢀII

Givenꢀanꢀintegerꢀn,ꢀgenerateꢀaꢀsquareꢀmatrixꢀfilledꢀwithꢀelementsꢀfromꢀ1ꢀtoꢀn2ꢀin

spiralꢀorder.

Forꢀexample,ꢀGivenꢀnꢀ=ꢀ3,

Youꢀshouldꢀreturnꢀtheꢀfollowingꢀmatrix:ꢀ[ꢀ[ꢀ1,ꢀ2,ꢀ3ꢀ],ꢀ[ꢀ8,ꢀ9,ꢀ4ꢀ],ꢀ[ꢀ7,ꢀ6,ꢀ5ꢀ]ꢀ]

URL:ꢀhttps://leetcode.com/problems/spiral-matrix-ii/

classꢀSolution(object):

ꢀꢀꢀꢀdefꢀgenerateMatrix(self,ꢀn):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀn:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀList[List[int]]

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀnꢀ==ꢀ0:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[]

ꢀꢀꢀꢀꢀꢀꢀꢀelifꢀnꢀ==ꢀ1:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ[[1]]

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#noꢀofꢀrows

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ=ꢀn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#noꢀofꢀcolumns

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ=ꢀn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#startꢀofꢀrow

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#startꢀofꢀcolumn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlꢀ=ꢀ0

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#allocateꢀaꢀsquareꢀmatrixꢀwithꢀallꢀzeros

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrixꢀ=ꢀ[[0ꢀforꢀjꢀinꢀrange(c)]ꢀforꢀiꢀinꢀrange(r)]

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#counterꢀforꢀtheꢀelements

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀwhileꢀkꢀ<ꢀrꢀandꢀlꢀ<ꢀc:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#fillꢀtheꢀfirstꢀrow

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(l,ꢀc):

221





SpiralꢀMatrixꢀII

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[k][i]ꢀ=ꢀcount

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀkꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#fillꢀtheꢀlastꢀcolumn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(k,ꢀr):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][c-1]ꢀ=ꢀcount

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#fillꢀtheꢀlastꢀrow

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀkꢀ<ꢀr:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(c-1,ꢀl-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[r-1][i]ꢀ=ꢀcount

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀrꢀ-=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀ#fillꢀtheꢀfirstꢀcolumn

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀlꢀ<ꢀc:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀforꢀiꢀinꢀrange(r-1,ꢀk-1,ꢀ-1):

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀmatrix[i][l]ꢀ=ꢀcount

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀcountꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀlꢀ+=ꢀ1

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀmatrix

222





Design

223





LRUꢀCache

LRUꢀCache

DesignꢀandꢀimplementꢀaꢀdataꢀstructureꢀforꢀLeastꢀRecentlyꢀUsedꢀ(LRU)ꢀcache.ꢀIt

shouldꢀsupportꢀtheꢀfollowingꢀoperations: ꢀgetꢀand ꢀsetꢀ.

ꢀget(key)ꢀ-ꢀGetꢀtheꢀvalueꢀ(willꢀalwaysꢀbeꢀpositive)ꢀofꢀtheꢀkeyꢀifꢀtheꢀkeyꢀexistsꢀin

theꢀcache,ꢀotherwiseꢀreturnꢀ-1.

ꢀset(key,ꢀvalue)ꢀ-ꢀSetꢀorꢀinsertꢀtheꢀvalueꢀifꢀtheꢀkeyꢀisꢀnotꢀalreadyꢀpresent.

Whenꢀtheꢀcacheꢀreachedꢀitsꢀcapacity,ꢀitꢀshouldꢀinvalidateꢀtheꢀleastꢀrecentlyꢀused

itemꢀbeforeꢀinsertingꢀaꢀnewꢀitem.

224





LRUꢀCache

classꢀLRUCache(object):

ꢀꢀꢀꢀdefꢀ\_\_init\_\_(self,ꢀcapacity):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀcapacity:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀself.capacityꢀ=ꢀcapacity

ꢀꢀꢀꢀꢀꢀꢀꢀself.cacheꢀ=ꢀOrderedDict()

ꢀꢀꢀꢀdefꢀget(self,ꢀkey):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀkeyꢀinꢀself.cache:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀvalueꢀ=ꢀself.cache.pop(key)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache[key]ꢀ=ꢀvalue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀvalue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀreturnꢀ-1

ꢀꢀꢀꢀdefꢀset(self,ꢀkey,ꢀvalue):

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀkey:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:typeꢀvalue:ꢀint

ꢀꢀꢀꢀꢀꢀꢀꢀ:rtype:ꢀnothing

ꢀꢀꢀꢀꢀꢀꢀꢀ"""

ꢀꢀꢀꢀꢀꢀꢀꢀifꢀlen(self.cache)ꢀ>=ꢀself.capacityꢀandꢀkeyꢀnotꢀinꢀself.

cache:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache.popitem(last=False)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache[key]ꢀ=ꢀvalue

ꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀifꢀkeyꢀinꢀself.cache:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache.pop(key)

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache[key]ꢀ=ꢀvalue

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀelse:

ꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀꢀself.cache[key]ꢀ=ꢀvalue

225





LRUꢀCache

226

